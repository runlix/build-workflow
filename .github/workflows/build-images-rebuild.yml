# Reusable Workflow for Multi-Architecture Docker Image Builds
# This workflow is called by service repositories for PR validation and releases
#
# Release mode behavior: Always rebuilds images from release branch for correctness
#
# Usage from service repository:
#   uses: runlix/build-workflow/.github/workflows/build-images-rebuild.yml@main
#   with:
#     pr_mode: true  # or false for release mode
#     dry_run: false # optional, skip push for testing

name: Build Multi-Arch Images

on:
  workflow_call:
    inputs:
      pr_mode:
        description: 'PR validation mode (true) or release mode (false)'
        required: true
        type: boolean
      dry_run:
        description: 'Skip image push to registry (for testing)'
        required: false
        type: boolean
        default: false
    secrets:
      RUNLIX_APP_ID:
        description: 'GitHub App ID for authenticated operations'
        required: true
      RUNLIX_PRIVATE_KEY:
        description: 'GitHub App private key for authenticated operations'
        required: true
      TELEGRAM_BOT_TOKEN:
        description: 'Telegram bot token for notifications (optional)'
        required: false
      TELEGRAM_CHAT_ID:
        description: 'Telegram chat ID for notifications (optional)'
        required: false

# Workflow-level environment variables
env:
  REGISTRY: ghcr.io
  REGISTRY_ORG: runlix

# Permissions required by this workflow
# Note: Calling workflow must grant these permissions via 'secrets: inherit'
permissions:
  contents: write       # Update releases.json in main branch (release mode only)
  packages: write       # Push images to GHCR, delete platform tags
  pull-requests: write  # Comment on PR with build results (PR mode only)
  actions: read         # Query workflow artifacts and PR status

jobs:
  # Job 1: Parse and validate docker-matrix.json
  # Expands variants √ó platforms into matrix for parallel builds
  parse-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.expand.outputs.matrix }}
      version: ${{ steps.extract.outputs.version }}
    steps:
      - name: Validate required secrets
        run: |
          echo "üîê Validating required secrets..."

          # Check GitHub App secrets (required for release mode)
          if [ "${{ inputs.pr_mode }}" == "false" ]; then
            if [ -z "${{ secrets.RUNLIX_APP_ID }}" ]; then
              echo "‚ùå ERROR: RUNLIX_APP_ID secret is required for release mode"
              exit 1
            fi
            if [ -z "${{ secrets.RUNLIX_PRIVATE_KEY }}" ]; then
              echo "‚ùå ERROR: RUNLIX_PRIVATE_KEY secret is required for release mode"
              exit 1
            fi
            echo "‚úÖ Required secrets for release mode are configured"
          else
            echo "‚úÖ PR mode - no secrets validation needed"
          fi

          # Check optional Telegram secrets
          if [ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ] && [ -n "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then
            echo "‚úÖ Telegram notifications configured"
          else
            echo "‚ÑπÔ∏è  Telegram notifications not configured (optional)"
          fi

      - name: Checkout calling repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          # For PR mode: checkout PR head SHA
          # For release mode: checkout release branch
          ref: ${{ inputs.pr_mode && github.event.pull_request.head.sha || github.ref }}

      - name: Setup Node.js for schema validation
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6
        with:
          node-version: '20'

      - name: Install ajv-cli for schema validation
        run: npm install -g ajv-cli ajv-formats

      - name: Validate schema
        run: |
          echo "üìã Validating docker-matrix.json against schema..."

          # Download schema from this repository
          curl -sSL https://raw.githubusercontent.com/runlix/build-workflow/main/schema/docker-matrix-schema.json -o /tmp/schema.json

          # Validate with clear error messages
          if ! ajv validate -s /tmp/schema.json -d .ci/docker-matrix.json --strict=false; then
            echo "‚ùå ERROR: docker-matrix.json validation failed"
            echo "Please ensure your configuration matches the schema at:"
            echo "https://github.com/runlix/build-workflow/blob/main/schema/docker-matrix-schema.json"
            exit 1
          fi

          echo "‚úÖ Schema validation passed"

      - name: Extract top-level fields
        id: extract
        run: |
          echo "üìã Extracting top-level fields from docker-matrix.json..."

          # Extract version (optional)
          VERSION=$(jq -r '.version // ""' .ci/docker-matrix.json)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Extract base_image fields (optional, for services)
          BASE_IMAGE=$(jq -r '.base_image.image // ""' .ci/docker-matrix.json)
          BASE_TAG=$(jq -r '.base_image.tag // ""' .ci/docker-matrix.json)
          BASE_DIGEST=$(jq -r '.base_image.digest // ""' .ci/docker-matrix.json)

          echo "base_image=$BASE_IMAGE" >> $GITHUB_OUTPUT
          echo "base_tag=$BASE_TAG" >> $GITHUB_OUTPUT
          echo "base_digest=$BASE_DIGEST" >> $GITHUB_OUTPUT

          # Log extracted values
          if [ -n "$VERSION" ]; then
            echo "Version: $VERSION"
          else
            echo "No version field (will use SHA-based versioning)"
          fi

          if [ -n "$BASE_IMAGE" ]; then
            echo "Base image: $BASE_IMAGE:$BASE_TAG@$BASE_DIGEST"
          else
            echo "No base_image (this is a base image repository)"
          fi

      - name: Validate variants
        run: |
          echo "üìã Validating variant configuration..."

          # Check at least one enabled variant exists
          ENABLED_COUNT=$(jq '[.variants[] | select(.enabled // true == true)] | length' .ci/docker-matrix.json)
          if [ "$ENABLED_COUNT" -eq 0 ]; then
            echo "‚ùå ERROR: No enabled variants found"
            echo "At least one variant must have 'enabled: true' or omit the enabled field"
            exit 1
          fi
          echo "‚úÖ Found $ENABLED_COUNT enabled variant(s)"

          # Check variant name uniqueness
          DUPLICATE_NAMES=$(jq -r '.variants[].name' .ci/docker-matrix.json | sort | uniq -d)
          if [ -n "$DUPLICATE_NAMES" ]; then
            echo "‚ùå ERROR: Duplicate variant names found:"
            echo "$DUPLICATE_NAMES"
            exit 1
          fi
          echo "‚úÖ All variant names are unique"

      - name: Validate platform-Dockerfile mapping
        run: |
          echo "üìã Validating platform-Dockerfile mappings..."

          # Check each variant's platforms have corresponding Dockerfiles
          jq -c '.variants[] | select(.enabled // true == true)' .ci/docker-matrix.json | while read variant; do
            VARIANT_NAME=$(echo "$variant" | jq -r '.name')
            echo "Checking variant: $VARIANT_NAME"

            # Check each platform has a Dockerfile
            echo "$variant" | jq -r '.platforms[]' | while read platform; do
              DOCKERFILE=$(echo "$variant" | jq -r --arg p "$platform" '.dockerfiles[$p]')

              if [ "$DOCKERFILE" == "null" ] || [ -z "$DOCKERFILE" ]; then
                echo "‚ùå ERROR: Variant '$VARIANT_NAME' platform '$platform' missing Dockerfile mapping"
                exit 1
              fi

              # Check if Dockerfile exists
              if [ ! -f "$DOCKERFILE" ]; then
                echo "‚ùå ERROR: Dockerfile not found: $DOCKERFILE"
                echo "Required by variant '$VARIANT_NAME' platform '$platform'"
                exit 1
              fi

              echo "  ‚úÖ $platform ‚Üí $DOCKERFILE"
            done
          done

          echo "‚úÖ All platform-Dockerfile mappings valid"

      - name: Expand matrix with auto-injection
        id: expand
        run: |
          echo "üìã Expanding matrix with auto-injection of BASE_* args..."

          # Get base_image fields for auto-injection
          BASE_IMAGE="${{ steps.extract.outputs.base_image }}"
          BASE_TAG="${{ steps.extract.outputs.base_tag }}"
          BASE_DIGEST="${{ steps.extract.outputs.base_digest }}"

          # Expand variants √ó platforms into matrix
          # Auto-inject BASE_IMAGE, BASE_TAG (with tag_suffix appended), BASE_DIGEST
          # Auto-select runner based on architecture for performance
          MATRIX=$(jq -c \
            --arg base_img "$BASE_IMAGE" \
            --arg base_tag "$BASE_TAG" \
            --arg base_digest "$BASE_DIGEST" '
            [
              .variants[]
              | select(.enabled // true == true)
              | .platforms[] as $platform
              | {
                  variant_name: .name,
                  platform: $platform,
                  arch: ($platform | split("/")[1]),
                  runner: (
                    if ($platform | split("/")[1]) == "arm64" then
                      "ubuntu-24.04-arm"
                    else
                      "ubuntu-24.04"
                    end
                  ),
                  dockerfile: .dockerfiles[$platform],
                  tag_suffix: .tag_suffix,
                  test_script: (.test_script // ""),
                  build_args: (
                    .build_args +
                    (if $base_img != "" then {
                      BASE_IMAGE: $base_img,
                      BASE_TAG: ($base_tag + "-" + .tag_suffix),
                      BASE_DIGEST: $base_digest
                    } else {} end)
                  )
                }
            ]
          ' .ci/docker-matrix.json)

          # Set matrix output
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT

          # Log matrix size and details
          MATRIX_SIZE=$(echo "$MATRIX" | jq 'length')
          echo "‚úÖ Matrix expanded: $MATRIX_SIZE jobs"
          echo ""
          echo "Matrix jobs:"
          echo "$MATRIX" | jq -r '.[] | "  - \(.variant_name) / \(.arch) on \(.runner)"'

      - name: Log disabled variants
        run: |
          DISABLED=$(jq -r '.variants[] | select(.enabled == false) | "‚ö†Ô∏è  Skipping disabled variant: \(.name)"' .ci/docker-matrix.json)
          if [ -n "$DISABLED" ]; then
            echo "$DISABLED"
          else
            echo "No disabled variants"
          fi

      - name: Log version type
        run: |
          VERSION="${{ steps.extract.outputs.version }}"
          if [ -n "$VERSION" ]; then
            echo "üì¶ Release mode: Versioned tags ($VERSION)"
          else
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            echo "üì¶ Release mode: SHA-based tags ($SHORT_SHA)"
          fi

  # Job 2: Build images (matrix strategy)
  # Runs in parallel for each variant+platform combination
  # PR mode: Build and test only (no push)
  # Release mode: Build, test, and push
  promote-or-build:
    needs: parse-matrix
    runs-on: ${{ matrix.runner }}
    timeout-minutes: 60  # Reduced from 120 - sufficient for most builds
    concurrency:
      group: build-${{ github.repository }}-${{ matrix.variant_name }}-${{ matrix.arch }}-${{ github.ref }}
      cancel-in-progress: ${{ inputs.pr_mode }}  # Cancel old PR builds, but not releases
    strategy:
      fail-fast: false  # Changed to false - allow other variants to complete even if one fails
      matrix:
        include: ${{ fromJson(needs.parse-matrix.outputs.matrix) }}
    env:
      SERVICE_NAME: ${{ github.event.repository.name }}
    steps:
      - name: Checkout calling repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - name: Generate release tag
        id: release-tag
        if: ${{ !inputs.pr_mode }}
        run: |
          VERSION="${{ needs.parse-matrix.outputs.version }}"
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)

          # Generate platform tag (temporary)
          # Format: <version>-<suffix>-<arch>-<sha> or <suffix>-<arch>-<sha>
          if [ -n "$VERSION" ]; then
            PLATFORM_TAG="${VERSION}-${{ matrix.tag_suffix }}-${{ matrix.arch }}-${SHORT_SHA}"
            echo "Platform tag (versioned): $PLATFORM_TAG"
          else
            # Base images without version use SHA at end
            PLATFORM_TAG="${{ matrix.tag_suffix }}-${{ matrix.arch }}-${SHORT_SHA}"
            echo "Platform tag (SHA-based): $PLATFORM_TAG"
          fi

          echo "platform_tag=$PLATFORM_TAG" >> $GITHUB_OUTPUT

      - name: Log in to GHCR (release mode only)
        if: ${{ !inputs.pr_mode && !inputs.dry_run }}
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up QEMU
        uses: docker/setup-qemu-action@c7c53464625b32c7a7e944ae62b3e17d2b600130 # v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Cache Docker layers
        uses: actions/cache@cdf6c1fa76f9f475f3d7449005a359c84ca0f306 # v5
        with:
          path: /tmp/.buildx-cache
          key: buildx-${{ matrix.variant_name }}-${{ matrix.platform }}-${{ github.sha }}
          restore-keys: |
            buildx-${{ matrix.variant_name }}-${{ matrix.platform }}-

      - name: Generate image tag
        id: tag
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)

          if ${{ inputs.pr_mode }}; then
            # PR mode: pr-<pr_number>-<version>-<suffix>-<arch>-<sha>
            PR_NUM=${{ github.event.pull_request.number }}
            VERSION="${{ needs.parse-matrix.outputs.version }}"

            if [ -n "$VERSION" ]; then
              IMAGE_TAG="${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:pr-${PR_NUM}-${VERSION}-${{ matrix.tag_suffix }}-${{ matrix.arch }}-${SHORT_SHA}"
            else
              IMAGE_TAG="${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:pr-${PR_NUM}-${{ matrix.tag_suffix }}-${{ matrix.arch }}-${SHORT_SHA}"
            fi
          else
            # Release mode rebuild: use platform tag from release-tag step
            PLATFORM_TAG="${{ steps.release-tag.outputs.platform_tag }}"
            IMAGE_TAG="${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:${PLATFORM_TAG}"
          fi

          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "üî® Building: $IMAGE_TAG"

      - name: Build image with OCI labels
        run: |
          VERSION="${{ needs.parse-matrix.outputs.version }}"
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Expand build_args from matrix (already includes auto-injected BASE_*)
          BUILD_ARGS=$(echo '${{ toJson(matrix.build_args) }}' | jq -r 'to_entries[] | "--build-arg \(.key)=\(.value)"' | tr '\n' ' ')

          # Build with OCI labels
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f ${{ matrix.dockerfile }} \
            $BUILD_ARGS \
            --label "org.opencontainers.image.revision=${{ github.sha }}" \
            --label "org.opencontainers.image.created=${BUILD_DATE}" \
            --label "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
            $([ -n "$VERSION" ] && echo "--label org.opencontainers.image.version=$VERSION" || echo "") \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
            --load \
            -t $IMAGE_TAG \
            .

          echo "‚úÖ Built: $IMAGE_TAG"

      - name: Run tests
        if: matrix.test_script != ''
        timeout-minutes: 10
        run: |
          echo "Running test script: ${{ matrix.test_script }}"
          chmod +x ${{ matrix.test_script }}
          ${{ matrix.test_script }}
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          PLATFORM: ${{ matrix.platform }}

      - name: Scan for vulnerabilities
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8 # 0.33.1+
        continue-on-error: true
        with:
          image-ref: ${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: 'trivy-results-${{ matrix.variant_name }}-${{ matrix.arch }}.sarif'
          severity: 'CRITICAL,HIGH'
          vuln-type: 'os,library'
          scanners: 'vuln,secret,config'
          timeout: '10m'
          # Skip DB update errors - workflow should continue
          exit-code: '0'

      - name: Push image with retry
        if: |
          !inputs.dry_run && !inputs.pr_mode
        uses: nick-fields/retry@ce71cc2ab81d554ebbe88c79ab5975992d79ba08 # v3
        with:
          timeout_minutes: 10
          max_attempts: 3
          retry_wait_seconds: 30
          exponential_backoff: true  # Exponential backoff: 30s, 60s, 120s
          command: docker push ${{ env.IMAGE_TAG }}

      - name: Save platform tag for manifest creation
        if: ${{ !inputs.pr_mode && success() }}
        run: |
          PLATFORM_TAG="${{ steps.release-tag.outputs.platform_tag }}"
          FILENAME="platform-tag-${{ matrix.variant_name }}-${{ matrix.arch }}.txt"

          echo "üì¶ Saving platform tag for manifest creation: $PLATFORM_TAG"
          echo "$PLATFORM_TAG" > "$FILENAME"

      - name: Upload platform tag artifact
        if: ${{ !inputs.pr_mode && success() }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6
        with:
          name: platform-tag-${{ matrix.variant_name }}-${{ matrix.arch }}
          path: platform-tag-${{ matrix.variant_name }}-${{ matrix.arch }}.txt
          retention-days: 1

      - name: Report failure to PR
        if: failure() && inputs.pr_mode
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚ùå **Build Failed**: ${{ matrix.variant_name }} / ${{ matrix.arch }}\n\n` +
                    `**Platform**: \`${{ matrix.platform }}\`\n` +
                    `**Dockerfile**: \`${{ matrix.dockerfile }}\`\n\n` +
                    `[View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
            })

      - name: Upload failure artifacts
        if: failure()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6
        with:
          name: failure-${{ matrix.variant_name }}-${{ matrix.arch }}
          path: |
            trivy-results-${{ matrix.variant_name }}-${{ matrix.arch }}.sarif
          retention-days: 7

      - name: Capture image digest
        if: success()
        id: digest
        run: |
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ env.IMAGE_TAG }} | cut -d'@' -f2)
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "Image: ${{ env.IMAGE_TAG }}@$DIGEST"

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  # Job 3: Collect results and create summary
  # Posts PR comments, generates manifest artifacts
  summary:
    needs: [parse-matrix, promote-or-build]
    runs-on: ubuntu-latest
    if: always()  # Run even if builds fail to report results
    env:
      SERVICE_NAME: ${{ github.event.repository.name }}
    steps:
      - name: Checkout calling repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - name: Download all artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7
        with:
          path: artifacts/

      - name: List downloaded artifacts
        run: |
          echo "üì¶ Downloaded artifacts:"
          if [ -d "artifacts" ]; then
            ls -R artifacts/
          else
            echo "No artifacts found (expected for successful PR builds)"
          fi

      - name: Parse vulnerability results
        id: vulns
        if: always()
        continue-on-error: true
        run: |
          echo "üîç Parsing vulnerability scan results..."

          # Count SARIF files
          VULN_COUNT=0
          CRITICAL_COUNT=0
          HIGH_COUNT=0
          MEDIUM_COUNT=0

          if [ -d "artifacts" ]; then
            VULN_COUNT=$(find artifacts/ -name "trivy-results-*.sarif" 2>/dev/null | wc -l)

            # Parse each SARIF file for CVE counts by severity
            for sarif in artifacts/failure-*/trivy-results-*.sarif; do
              if [ -f "$sarif" ]; then
                # Count by severity level
                # SARIF format: .runs[].results[] with .level property
                CRITICAL=$(jq '[.runs[].results[]? | select(.level=="error" and (.properties."security-severity"? // "0" | tonumber) >= 9.0)] | length' "$sarif" 2>/dev/null || echo "0")
                HIGH=$(jq '[.runs[].results[]? | select(.level=="error" and (.properties."security-severity"? // "0" | tonumber) >= 7.0 and (.properties."security-severity"? // "0" | tonumber) < 9.0)] | length' "$sarif" 2>/dev/null || echo "0")
                MEDIUM=$(jq '[.runs[].results[]? | select(.level=="warning")] | length' "$sarif" 2>/dev/null || echo "0")

                CRITICAL_COUNT=$((CRITICAL_COUNT + CRITICAL))
                HIGH_COUNT=$((HIGH_COUNT + HIGH))
                MEDIUM_COUNT=$((MEDIUM_COUNT + MEDIUM))
              fi
            done
          fi

          echo "vuln_file_count=$VULN_COUNT" >> $GITHUB_OUTPUT
          echo "critical_count=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
          echo "high_count=$HIGH_COUNT" >> $GITHUB_OUTPUT
          echo "medium_count=$MEDIUM_COUNT" >> $GITHUB_OUTPUT

          echo "Found $VULN_COUNT vulnerability scan(s)"
          echo "  Critical: $CRITICAL_COUNT"
          echo "  High: $HIGH_COUNT"
          echo "  Medium: $MEDIUM_COUNT"

      - name: Check build status
        id: status
        run: |
          # Check if promote-or-build job succeeded
          if [ "${{ needs.promote-or-build.result }}" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "status_emoji=‚úÖ" >> $GITHUB_OUTPUT
            echo "status_text=All builds succeeded" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "status_emoji=‚ùå" >> $GITHUB_OUTPUT
            echo "status_text=Some builds failed" >> $GITHUB_OUTPUT
          fi

      - name: Generate PR comment body
        if: inputs.pr_mode
        id: comment
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          PR_NUM=${{ github.event.pull_request.number }}

          # Build comment body
          cat > comment.md <<'EOF'
          ${{ steps.status.outputs.status_emoji }} **Docker Build Report**

          **Status**: ${{ steps.status.outputs.status_text }}
          **PR**: #${{ github.event.pull_request.number }}
          **Commit**: `${{ github.sha }}`

          EOF

          # Add vulnerability scan info
          VULN_COUNT=${{ steps.vulns.outputs.vuln_file_count }}
          CRITICAL=${{ steps.vulns.outputs.critical_count }}
          HIGH=${{ steps.vulns.outputs.high_count }}
          MEDIUM=${{ steps.vulns.outputs.medium_count }}

          if [ "$VULN_COUNT" -gt 0 ]; then
            cat >> comment.md <<VULNEOF

          ---

          ### Security Scans

          üîç Vulnerability scans completed for $VULN_COUNT image(s).

          **Vulnerabilities Found:**
          - üî¥ Critical: $CRITICAL
          - üü† High: $HIGH
          - üü° Medium: $MEDIUM

          [View SARIF Results](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          VULNEOF
          fi

          # Add workflow link
          cat >> comment.md <<'LINKEOF'

          ---

          [View Full Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          LINKEOF

          echo "‚úÖ Generated PR comment"
          cat comment.md

      - name: Post PR comment
        if: inputs.pr_mode
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const fs = require('fs');
            const commentBody = fs.readFileSync('comment.md', 'utf8');

            // Find existing comment from this workflow
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Docker Build Report')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
              console.log('Updated existing PR comment');
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
              console.log('Created new PR comment');
            }

      - name: Release mode summary
        if: ${{ !inputs.pr_mode }}
        run: |
          echo "üöÄ Release Summary"
          echo "=================="
          echo ""
          echo "Service: $SERVICE_NAME"

          VERSION="${{ needs.parse-matrix.outputs.version }}"
          if [ -n "$VERSION" ]; then
            echo "Version: $VERSION"
          else
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            echo "Version: $SHORT_SHA (SHA-based)"
          fi

          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "Platform images will be collected by create-manifests job"
          echo "Manifests will be created after all platforms complete"

      - name: Summary output
        run: |
          echo "üìä Build Summary"
          echo "================"
          echo "Status: ${{ steps.status.outputs.status_text }}"
          echo "Vulnerability Scans: ${{ steps.vulns.outputs.vuln_file_count }}"
          echo ""

          if [ "${{ steps.status.outputs.status }}" == "failure" ]; then
            echo "‚ö†Ô∏è  Some builds failed. Check the logs above for details."
            exit 1
          fi

  # Job 4: Create multi-arch manifests (release mode only)
  # Collects platform tags and creates permanent manifest lists
  create-manifests:
    needs: [parse-matrix, promote-or-build]
    if: ${{ !inputs.pr_mode }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      SERVICE_NAME: ${{ github.event.repository.name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - name: Setup crane
        run: |
          # Detect architecture
          ARCH=$(uname -m)
          case $ARCH in
            x86_64)
              CRANE_ARCH="x86_64"
              ;;
            aarch64|arm64)
              CRANE_ARCH="arm64"
              ;;
            *)
              echo "Unsupported architecture: $ARCH"
              exit 1
              ;;
          esac

          echo "Installing crane for Linux $CRANE_ARCH..."

          # Get latest release
          CRANE_VERSION=$(curl -s https://api.github.com/repos/google/go-containerregistry/releases/latest | jq -r .tag_name)

          # Download and install
          curl -fsSL "https://github.com/google/go-containerregistry/releases/download/${CRANE_VERSION}/go-containerregistry_Linux_${CRANE_ARCH}.tar.gz" | \
            sudo tar xz -C /usr/local/bin crane

          # Verify installation
          crane version
          echo "‚úÖ Installed crane ${CRANE_VERSION} for ${CRANE_ARCH}"

      - name: Log in to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download platform tags
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7
        with:
          pattern: platform-tag-*
          path: platform-tags/
          merge-multiple: true

      - name: List downloaded artifacts
        run: |
          echo "üì¶ Downloaded platform tags:"
          ls -la platform-tags/

      - name: Create multi-arch manifests
        id: manifests
        run: |
          set -euo pipefail  # Exit on error, undefined vars, pipe failures

          VERSION="${{ needs.parse-matrix.outputs.version }}"
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)

          # Extract unique tag suffixes from matrix
          TAG_SUFFIXES=$(echo '${{ needs.parse-matrix.outputs.matrix }}' | \
            jq -r '[.[] | .tag_suffix] | unique | .[]')

          echo "üî® Creating multi-arch manifests:"
          echo ""

          # Create manifests-created.txt for tracking
          touch manifests-created.txt

          # Track success/failure
          MANIFEST_SUCCESS=true

          # For each unique tag suffix, create a multi-arch manifest
          echo "$TAG_SUFFIXES" | while read TAG_SUFFIX; do
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Tag Suffix: $TAG_SUFFIX"
            echo ""

            # Determine manifest tag
            # Format: <version>-<suffix> or <suffix>
            if [ -n "$VERSION" ]; then
              MANIFEST_TAG="${VERSION}-${TAG_SUFFIX}"
            else
              MANIFEST_TAG="${TAG_SUFFIX}"
            fi

            echo "Target manifest tag: $MANIFEST_TAG"

            # Collect ALL platform images with this manifest tag (across all architectures)
            # Platform tags have format: <version>-<suffix>-<arch>-<sha> or <suffix>-<arch>-<sha>
            # So they start with the manifest tag followed by a dash
            PLATFORM_IMAGES=()
            for tag_file in platform-tags/platform-tag-*.txt; do
              if [ -f "$tag_file" ]; then
                PLATFORM_TAG=$(cat "$tag_file")
                # Check if platform tag starts with manifest tag + dash
                if [[ "$PLATFORM_TAG" == "${MANIFEST_TAG}-"* ]]; then
                  FULL_IMAGE="${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:${PLATFORM_TAG}"
                  PLATFORM_IMAGES+=("$FULL_IMAGE")
                  echo "  + Platform: $PLATFORM_TAG"
                fi
              fi
            done

            if [ ${#PLATFORM_IMAGES[@]} -eq 0 ]; then
              echo "‚ùå Error: No platform images found for manifest tag $MANIFEST_TAG"
              exit 1
            fi

            echo ""
            echo "Creating multi-arch manifest with ${#PLATFORM_IMAGES[@]} platform(s)..."

            # Create multi-arch manifest
            docker buildx imagetools create \
              -t "${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:${MANIFEST_TAG}" \
              "${PLATFORM_IMAGES[@]}"

            echo "‚úÖ Created: $MANIFEST_TAG"
            echo "$MANIFEST_TAG" >> manifests-created.txt
            echo ""
          done

          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ All manifests created successfully"

      - name: Cleanup platform tags
        continue-on-error: true
        run: |
          echo "üßπ Cleaning up temporary platform tags..."
          echo ""

          SUCCESS_COUNT=0
          FAIL_COUNT=0

          for tag_file in platform-tags/platform-tag-*.txt; do
            if [ -f "$tag_file" ]; then
              PLATFORM_TAG=$(cat "$tag_file")
              FULL_IMAGE="${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:${PLATFORM_TAG}"

              echo "Deleting: $PLATFORM_TAG"

              if crane delete "$FULL_IMAGE" 2>/dev/null; then
                ((SUCCESS_COUNT++))
              else
                echo "  ‚ö†Ô∏è Failed to delete (may already be gone)"
                ((FAIL_COUNT++))
              fi
            fi
          done

          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Cleanup complete: $SUCCESS_COUNT deleted, $FAIL_COUNT failed"
          echo "Platform tags were temporary - manifests are permanent"

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2
        with:
          app-id: ${{ secrets.RUNLIX_APP_ID }}
          private-key: ${{ secrets.RUNLIX_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Get GitHub App Bot User ID
        id: get-user-id
        run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Checkout main branch
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6
        with:
          ref: main
          path: main-branch
          token: ${{ steps.app-token.outputs.token }}

      - name: Update releases.json
        run: |
          cd main-branch

          VERSION="${{ needs.parse-matrix.outputs.version }}"
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          MANIFESTS=$(cat ../manifests-created.txt | jq -R -s 'split("\n") | map(select(length > 0))')

          # Read or create releases.json
          if [ -f releases.json ]; then
            RELEASES=$(cat releases.json)
          else
            RELEASES='{}'
          fi

          # Update entry for this service
          RELEASES=$(echo "$RELEASES" | jq \
            --arg service "$SERVICE_NAME" \
            --arg version "$VERSION" \
            --arg sha "${{ github.sha }}" \
            --arg short_sha "$SHORT_SHA" \
            --arg timestamp "$TIMESTAMP" \
            --argjson manifests "$MANIFESTS" \
            '.[$service] = {
              version: (if $version != "" then $version else null end),
              sha: $sha,
              short_sha: $short_sha,
              timestamp: $timestamp,
              manifests: $manifests
            }')

          # Write updated releases.json
          echo "$RELEASES" | jq '.' > releases.json

          echo "‚úÖ Updated releases.json for $SERVICE_NAME"
          echo ""
          echo "Release entry:"
          echo "$RELEASES" | jq --arg service "$SERVICE_NAME" '.[$service]'

      - name: Commit and push releases.json
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          cd main-branch

          # Configure git with GitHub App credentials
          git config user.name '${{ steps.app-token.outputs.app-slug }}[bot]'
          git config user.email '${{ steps.get-user-id.outputs.user-id }}+${{ steps.app-token.outputs.app-slug }}[bot]@users.noreply.github.com'

          # Setup git authentication for push
          gh auth setup-git

          git add releases.json

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            VERSION="${{ needs.parse-matrix.outputs.version }}"
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)

            if [ -n "$VERSION" ]; then
              COMMIT_MSG="Release: $SERVICE_NAME $VERSION @ $SHORT_SHA"
            else
              COMMIT_MSG="Release: $SERVICE_NAME @ $SHORT_SHA"
            fi

            git commit -m "$COMMIT_MSG"
            git push

            echo "‚úÖ Pushed releases.json to main branch"
          fi

      - name: Upload manifest list
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6
        with:
          name: manifests-created
          path: manifests-created.txt
          retention-days: 90

      - name: Send release notification
        if: ${{ !inputs.pr_mode }}
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          VERSION="${{ needs.parse-matrix.outputs.version }}"
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          MANIFESTS=$(cat manifests-created.txt | tr '\n' ', ' | sed 's/,$//')

          # Mask secrets in logs (GitHub Actions security best practice)
          if [ -n "$TELEGRAM_BOT_TOKEN" ]; then
            echo "::add-mask::$TELEGRAM_BOT_TOKEN"
          fi
          if [ -n "$TELEGRAM_CHAT_ID" ]; then
            echo "::add-mask::$TELEGRAM_CHAT_ID"
          fi

          echo "üì¢ Sending release notification..."
          echo "Service: $SERVICE_NAME"
          if [ -n "$VERSION" ]; then
            echo "Version: $VERSION"
          else
            echo "Version: $SHORT_SHA (SHA-based)"
          fi
          echo "Manifests: $MANIFESTS"

          # Prepare notification message (Telegram supports HTML and Markdown)
          if [ -n "$VERSION" ]; then
            VERSION_LINE="*Version:* \`$VERSION\`"
          else
            VERSION_LINE="*Version:* \`$SHORT_SHA\` (SHA-based)"
          fi

          MESSAGE=$(cat <<EOF
          üéâ *Docker Release Complete*

          *Service:* \`$SERVICE_NAME\`
          $VERSION_LINE
          *Commit:* [\`$SHORT_SHA\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})

          *Manifests Created:*
          \`$MANIFESTS\`

          *Registry:*
          \`${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}\`

          [View Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )

          # Send to Telegram bot if configured
          if [ -n "$TELEGRAM_BOT_TOKEN" ] && [ -n "$TELEGRAM_CHAT_ID" ]; then
            echo "Sending to Telegram..."

            # Send via Telegram Bot API (using env vars to avoid exposing in command)
            RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d "chat_id=${TELEGRAM_CHAT_ID}" \
              -d "text=${MESSAGE}" \
              -d "parse_mode=Markdown" \
              -d "disable_web_page_preview=true" 2>&1)

            # Check if successful (avoid logging response that might contain sensitive data)
            if echo "$RESPONSE" | jq -e '.ok == true' > /dev/null 2>&1; then
              echo "‚úÖ Notification sent to Telegram"
            else
              echo "‚ö†Ô∏è  Telegram API returned error (check bot token and chat ID configuration)"
              # Only log non-sensitive error description
              ERROR_DESC=$(echo "$RESPONSE" | jq -r '.description // "Unknown error"' 2>/dev/null || echo "Unknown error")
              echo "Error: $ERROR_DESC"
            fi
          else
            echo "‚ö†Ô∏è  TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID not configured, skipping notification"
            echo "To enable notifications:"
            echo "  1. Create a bot via @BotFather on Telegram"
            echo "  2. Get your chat ID by messaging @userinfobot"
            echo "  3. Add secrets: TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID"
          fi

          # Alternative: Create GitHub Release (commented out, enable if needed)
          # gh release create "$VERSION" \
          #   --title "Release $VERSION" \
          #   --notes "Automated release of $SERVICE_NAME $VERSION
          #
          # **Manifests Created:**
          # $(cat manifests-created.txt | sed 's/^/- /')
          #
          # **Commit:** ${{ github.sha }}
          # **Registry:** ${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}" \
          #   --repo ${{ github.repository }}

      - name: Release complete
        run: |
          echo "üéâ Release Complete"
          echo "==================="
          echo ""
          echo "Service: $SERVICE_NAME"

          VERSION="${{ needs.parse-matrix.outputs.version }}"
          if [ -n "$VERSION" ]; then
            echo "Version: $VERSION"
          else
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            echo "Version: $SHORT_SHA (SHA-based)"
          fi

          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "Created manifests:"
          cat manifests-created.txt | sed 's/^/  - /'
          echo ""
          echo "Registry: ${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}"
          echo ""
          echo "Pull commands:"
          cat manifests-created.txt | while read tag; do
            echo "  docker pull ${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:$tag"
          done

# Workflow outputs:
# - PR mode: Platform-specific images tagged pr-{number}-{version}-{suffix}-{arch}-{sha}
#            (version omitted for SHA-based services)
#            Images are built and tested but NOT pushed to registry
# - Release mode: Rebuilds from release branch, creates multi-arch manifests
#                 tagged {version}-{suffix} or {suffix} (SHA-based)
