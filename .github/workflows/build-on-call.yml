name: Build on Call

on:
  workflow_call:

jobs:
  prepare-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract.outputs.version }}
      build_date: ${{ steps.extract.outputs.build_date }}
      branch: ${{ steps.extract.outputs.branch }}
      sha: ${{ steps.extract.outputs.sha }}
      default_branch: ${{ steps.extract.outputs.default_branch }}
      variants: ${{ steps.extract.outputs.variants }}
      matrix: ${{ steps.extract.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract metadata from VERSION.json
        id: extract
        run: |
          # Extract version and build_date
          VERSION=$(jq -r '.version // empty' VERSION.json 2>/dev/null | grep -v "^null$" || echo "")
          BUILD_DATE=$(jq -r '.build_date // empty' VERSION.json 2>/dev/null | grep -v "^null$" || echo "")
          
          # Extract enabled targets matrix
          MATRIX=$(jq '[ .targets[] | select(.enabled == true) ]' VERSION.json)
          
          # Extract unique variants
          VARIANTS=$(jq -r '.targets[] | select(.enabled == true) | .variant' VERSION.json | sort -u)
          
          # GitHub context values
          BRANCH="${{ github.ref_name }}"
          SHA="${{ github.sha }}"
          DEFAULT_BRANCH="${{ github.event.repository.default_branch }}"
          
          # Output all values
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "build_date=${BUILD_DATE}" >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "sha=${SHA}" >> $GITHUB_OUTPUT
          echo "default_branch=${DEFAULT_BRANCH}" >> $GITHUB_OUTPUT
          {
            echo 'variants<<EOF'
            echo "$VARIANTS"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"
          {
            echo 'matrix<<EOF'
            echo "$MATRIX"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

  build:
    needs: prepare-version
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target: ${{ fromJson(needs.prepare-version.outputs.matrix) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN }}  

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          image: tonistiigi/binfmt:qemu-v9.2.2

      - name: Generate build metadata
        id: metadata
        run: |
          CREATED=$(date -u +'%Y-%m-%dT%H:%M:%S.000Z')
          ARCH="${{ matrix.target.arch }}"
          PLATFORM="${ARCH//linux-/linux/}"  # Replaces 'linux-' with 'linux/'
          echo "created=${CREATED}" >> $GITHUB_OUTPUT
          echo "platform=${PLATFORM}" >> $GITHUB_OUTPUT

      - name: Prepare build args
        id: prepare-build-args
        run: |
          # Build the build-args multiline string line by line to avoid indentation issues
          {
            echo "BUILDER_TAG=${{ matrix.target.builder.tag }}"
            echo "BUILDER_DIGEST=${{ matrix.target.builder.digest }}"
            echo "BASE_TAG=${{ matrix.target.base.tag }}"
            echo "BASE_DIGEST=${{ matrix.target.base.digest }}"
            echo "VERSION=${{ needs.prepare-version.outputs.version }}"
            echo "BUILD_DATE=${{ needs.prepare-version.outputs.build_date }}"
            echo "GIT_COMMIT=${{ needs.prepare-version.outputs.sha }}"
            
            # Conditionally add PACKAGE_URL if it exists in the target
            PACKAGE_URL="${{ matrix.target.package_url }}"
            if [ -n "$PACKAGE_URL" ] && [ "$PACKAGE_URL" != "null" ]; then
              echo "PACKAGE_URL=${PACKAGE_URL}"
            fi
          } > /tmp/build_args.txt
          
          # Output build args using multiline format (required for GitHub Actions multiline outputs)
          {
            echo 'build_args<<EOF'
            cat /tmp/build_args.txt
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ matrix.target.dockerfile }}
          platforms: ${{ steps.metadata.outputs.platform }}
          push: true
          tags: ghcr.io/${{ github.repository }}:${{ needs.prepare-version.outputs.branch }}-${{ needs.prepare-version.outputs.version }}-${{ matrix.target.name }}
          provenance: false
          build-args: ${{ steps.prepare-build-args.outputs.build_args }}
          labels: |
            org.opencontainers.image.created=${{ steps.metadata.outputs.created }}
            org.opencontainers.image.title=${{ github.repository }}:${{ needs.prepare-version.outputs.branch }}
            org.opencontainers.image.revision=${{ needs.prepare-version.outputs.sha }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}/tree/${{ needs.prepare-version.outputs.branch }}
            org.opencontainers.image.vendor=${{ github.repository_owner }}
            org.opencontainers.image.version=${{ needs.prepare-version.outputs.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  publish:
    needs: [build, prepare-version]
    if: success()
    runs-on: ubuntu-latest
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN }}
      
      - name: Create and push manifest lists
        uses: nick-fields/retry@v3
        env:
          VARIANTS: ${{ needs.prepare-version.outputs.variants }}
          VERSION: ${{ needs.prepare-version.outputs.version }}
          BRANCH: ${{ needs.prepare-version.outputs.branch }}
          SHA: ${{ needs.prepare-version.outputs.sha }}
          REPOSITORY: ${{ github.repository }}
          MATRIX: ${{ needs.prepare-version.outputs.matrix }}
        with:
          max_attempts: 3
          timeout_minutes: 5
          retry_wait_seconds: 30
          command: |
            # For each variant, collect platform images and create manifest list
            echo "$VARIANTS" | while IFS= read -r variant; do
              echo "Processing variant: $variant"
              
              # Get all enabled targets for this variant from matrix JSON
              TARGETS=$(echo "$MATRIX" | jq -r --arg v "$variant" '.[] | select(.variant == $v) | .name')
              
              # Build image tag list and verify existence
              PLATFORM_IMAGES=()
              for target in $TARGETS; do
                IMAGE_TAG="ghcr.io/${REPOSITORY}:${BRANCH}-${VERSION}-${target}"
                if docker buildx imagetools inspect "$IMAGE_TAG" >/dev/null 2>&1; then
                  PLATFORM_IMAGES+=("$IMAGE_TAG")
                  echo "  ✓ Found: $IMAGE_TAG"
                else
                  echo "  ✗ Missing: $IMAGE_TAG"
                fi
              done
              
              # Only create manifest if we have at least 2 platforms
              if [ ${#PLATFORM_IMAGES[@]} -lt 2 ]; then
                echo "Skipping manifest creation for $variant: only ${#PLATFORM_IMAGES[@]} platform(s) available"
                continue
              fi
              
              # Define primary tag (first tag becomes the manifest reference)
              PRIMARY_TAG="ghcr.io/${REPOSITORY}:${BRANCH}-${variant}"
              
              # Create manifest list once with primary tag
              echo "Creating manifest list: $PRIMARY_TAG"
              docker buildx imagetools create \
                --tag "$PRIMARY_TAG" \
                "${PLATFORM_IMAGES[@]}"
              
              # Create additional tags as aliases pointing to the same manifest
              # This is more efficient than creating separate manifests (matches Hotio pattern)
              echo "Creating tag alias: ${BRANCH}-${VERSION}-${variant}"
              docker buildx imagetools create \
                --tag "ghcr.io/${REPOSITORY}:${BRANCH}-${VERSION}-${variant}" \
                "$PRIMARY_TAG"
              
              echo "Creating tag alias: ${BRANCH}-${SHA:0:7}-${variant}"
              docker buildx imagetools create \
                --tag "ghcr.io/${REPOSITORY}:${BRANCH}-${SHA:0:7}-${variant}" \
                "$PRIMARY_TAG"
              
              echo "✓ Manifest list created for variant: $variant with all tag aliases"
            done
      
      - name: Checkout default branch for tags.json
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare-version.outputs.default_branch }}
          fetch-depth: 0
      
      - name: Update tags.json
        uses: nick-fields/retry@v3
        env:
          RUN_ID: ${{ github.run_id }}
          REPOSITORY: ${{ github.repository }}
          SERVER_URL: ${{ github.server_url }}
          BRANCH: ${{ needs.prepare-version.outputs.branch }}
          VERSION: ${{ needs.prepare-version.outputs.version }}
          SHA: ${{ needs.prepare-version.outputs.sha }}
          VARIANTS: ${{ needs.prepare-version.outputs.variants }}
        with:
          max_attempts: 3
          timeout_minutes: 5
          retry_wait_seconds: 30
          command: |
            set -e
            
            # Pull latest changes to handle concurrent updates
            git pull --rebase || true
            
            # Create tags.json if it doesn't exist
            [ ! -f tags.json ] && echo '{}' > tags.json
            
            # Generate timestamp
            TIMESTAMP=$(date -u +'%Y-%m-%dT%H:%M:%S.000Z')
            BUILD_URL="${SERVER_URL}/${REPOSITORY}/actions/runs/${RUN_ID}"
            
            # Update tags.json for each variant (matching publish job tag format)
            echo "$VARIANTS" | while IFS= read -r variant; do
              # Create tags matching publish job format: branch-variant, branch-version-variant, branch-sha-variant
              TAG_BRANCH_VARIANT="${BRANCH}-${variant}"
              TAG_BRANCH_VERSION_VARIANT="${BRANCH}-${VERSION}-${variant}"
              TAG_BRANCH_SHA_VARIANT="${BRANCH}-${SHA:0:7}-${variant}"
              
              # Update tags.json using jq (same structure as publish job creates)
              jq --sort-keys \
                  --arg branch_variant "${TAG_BRANCH_VARIANT}" \
                  --arg tag_branch_variant "${TAG_BRANCH_VARIANT}" \
                  --arg tag_branch_version_variant "${TAG_BRANCH_VERSION_VARIANT}" \
                  --arg tag_branch_sha_variant "${TAG_BRANCH_SHA_VARIANT}" \
                  --arg last_updated "${TIMESTAMP}" \
                  --arg last_updated_url "${BUILD_URL}" \
                  --arg description "${TAG_BRANCH_VARIANT}" \
                  --argjson hide false \
                  '.[$branch_variant] = {
                    "description": $description,
                    "hide": $hide,
                    "last_updated": $last_updated,
                    "last_updated_url": $last_updated_url,
                    "tags": [$tag_branch_variant, $tag_branch_version_variant, $tag_branch_sha_variant]
                  }' tags.json > tags.json.tmp && mv tags.json.tmp tags.json
            done
            
            # Only commit if tags.json actually changed
            if ! git diff --quiet tags.json; then
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git add tags.json
              git commit -m "Update tags.json for ${BRANCH} branch variants (version: ${VERSION}) [skip ci]" || exit 0
              git push || { echo "Error: Failed to push tags.json update"; exit 1; }
            else
              echo "No changes to tags.json, skipping commit"
            fi
          new_command_on_retry: |
            git pull --rebase
            git push

  # TODO: Add notification job to send build status notifications
  # This job should:
  # - Run after publish job completes (success or failure)
  # - Send notifications to one or more messaging platforms:
  #   * WhatsApp (via WhatsApp Business API or third-party service)
  #   * Telegram (via Telegram Bot API)
  #   * Discord (via Discord Webhook)
  #   * Slack (via Slack Webhook)
  #   * Email (via SMTP)
  # - Include build metadata: branch, version, SHA, build status, workflow run URL
  # - Support configurable notification channels via secrets (e.g., NOTIFICATION_WEBHOOK_URL, TELEGRAM_BOT_TOKEN, etc.)
  # - Handle both success and failure scenarios with appropriate messaging
  # Example structure:
  # notify:
  #   needs: [publish, build]
  #   if: always()  # Run regardless of previous job status
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Send notification
  #       run: |
  #         # Send to configured notification channels
  #         # Include build status, branch, version, SHA, workflow URL