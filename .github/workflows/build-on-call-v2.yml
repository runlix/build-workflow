name: Build on Call

on:
  workflow_call:

jobs:
  generate-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.extract.outputs.matrix }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract enabled targets
        id: extract
        run: |
          MATRIX=$(jq '[ .targets[] | select(.enabled == true) ]' VERSION.json)
          {
            echo 'matrix<<EOF'
            echo "$MATRIX"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

  build:
    needs: generate-matrix
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.prep.outputs.version }}
      branch: ${{ steps.prep.outputs.branch }}
      sha: ${{ steps.prep.outputs.sha }}
      image_tag_branch: ${{ steps.prep.outputs.image_tag_branch }}
      image_tag_branch_version: ${{ steps.prep.outputs.image_tag_branch_version }}
      image_tag_branch_sha: ${{ steps.prep.outputs.image_tag_branch_sha }}
    strategy:
      matrix:
        target: ${{ fromJson(needs.generate-matrix.outputs.matrix) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN }}  

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          image: tonistiigi/binfmt:qemu-v9.2.2

      - name: Create Outputs for Next Steps
        id: prep
        run: |
          # Helper function to safely extract JSON values
          get_json_value() {
            jq -r "${1} // empty" VERSION.json 2>/dev/null | grep -v "^null$" || echo ""
          }
          
          # Extract root-level metadata from VERSION.json
          VERSION=$(get_json_value '.version')
          BUILD_DATE=$(get_json_value '.build_date')
          
          # Generate PACKAGE_VERSION (branch-sha format)
          GIT_SHA="${{ github.sha }}"
          PACKAGE_VERSION="${{ github.ref_name }}-${GIT_SHA:0:7}"
          
          # Generate IMAGE_TAG (branch-version-target.name format)
          IMAGE_TAG="${{ github.ref_name }}-${VERSION}-${{ matrix.target.name }}"
          
          # Extract target-specific parameters
          BUILDER_TAG="${{ matrix.target.builder.tag }}"
          BUILDER_DIGEST="${{ matrix.target.builder.digest }}"
          BASE_TAG="${{ matrix.target.base.tag }}"
          BASE_DIGEST="${{ matrix.target.base.digest }}"
          GIT_COMMIT="${{ github.sha }}"
          
          # Convert architecture format (linux-amd64 â†’ linux/amd64)
          ARCH=$(echo "${{ matrix.target.arch }}" | sed 's/linux-/linux\//')
          PLATFORM="${ARCH}"
          
          # Generate label values
          CREATED=$(date -u +'%Y-%m-%dT%H:%M:%S.000Z')
          REPOSITORY="${{ github.repository }}"
          REPOSITORY_OWNER="${{ github.repository_owner }}"
          BRANCH="${{ github.ref_name }}"
          SERVER_URL="${{ github.server_url }}"
          SOURCE="${SERVER_URL}/${REPOSITORY}/tree/${BRANCH}"
          IMAGE_TAG_BRANCH="${REPOSITORY}:${BRANCH}"
          DEFAULT_BRANCH="${{ github.event.repository.default_branch }}"
          
          # Generate image tags for tags.json (using variant from first enabled target)
          # These will be updated by the publish job with actual variant tags
          IMAGE_TAG_BRANCH_VERSION="${REPOSITORY}:${BRANCH}-${VERSION}"
          IMAGE_TAG_BRANCH_SHA="${REPOSITORY}:${BRANCH}-${GIT_SHA:0:7}"
          
          # Output all values to GITHUB_OUTPUT for use in subsequent steps
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "build_date=${BUILD_DATE}" >> $GITHUB_OUTPUT
          echo "git_commit=${GIT_COMMIT}" >> $GITHUB_OUTPUT
          echo "package_version=${PACKAGE_VERSION}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "builder_tag=${BUILDER_TAG}" >> $GITHUB_OUTPUT
          echo "builder_digest=${BUILDER_DIGEST}" >> $GITHUB_OUTPUT
          echo "base_tag=${BASE_TAG}" >> $GITHUB_OUTPUT
          echo "base_digest=${BASE_DIGEST}" >> $GITHUB_OUTPUT
          echo "platform=${PLATFORM}" >> $GITHUB_OUTPUT
          echo "dockerfile=${{ matrix.target.dockerfile }}" >> $GITHUB_OUTPUT
          # Label values
          echo "label_created=${CREATED}" >> $GITHUB_OUTPUT
          echo "label_title=${IMAGE_TAG_BRANCH}" >> $GITHUB_OUTPUT
          echo "label_revision=${GIT_COMMIT}" >> $GITHUB_OUTPUT
          echo "label_source=${SOURCE}" >> $GITHUB_OUTPUT
          echo "label_vendor=${REPOSITORY_OWNER}" >> $GITHUB_OUTPUT
          echo "label_version=${VERSION}" >> $GITHUB_OUTPUT
          # Outputs for tags job
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "sha=${GIT_SHA}" >> $GITHUB_OUTPUT
          echo "image_tag_branch=${IMAGE_TAG_BRANCH}" >> $GITHUB_OUTPUT
          echo "image_tag_branch_version=${IMAGE_TAG_BRANCH_VERSION}" >> $GITHUB_OUTPUT
          echo "image_tag_branch_sha=${IMAGE_TAG_BRANCH_SHA}" >> $GITHUB_OUTPUT
          
          # Echo all parameters organized by category
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“‹ METADATA"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  VERSION:           ${VERSION}"
          echo "  BUILD_DATE:        ${BUILD_DATE}"
          echo "  GIT_COMMIT:        ${GIT_COMMIT}"
          echo "  PACKAGE_VERSION:   ${PACKAGE_VERSION}"
          echo "  IMAGE_TAG:         ${IMAGE_TAG}"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ”§ TARGET CONFIGURATION"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Target Name:       ${{ matrix.target.name }}"
          echo "  Architecture:      ${{ matrix.target.arch }}"
          echo "  Dockerfile:        ${{ matrix.target.dockerfile }}"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ—ï¸  BUILDER IMAGE"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  BUILDER_TAG:       ${BUILDER_TAG}"
          echo "  BUILDER_DIGEST:    ${BUILDER_DIGEST}"
          echo "  Builder Image:     ${{ matrix.target.builder.image }}"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“¦ BASE IMAGE"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  BASE_TAG:          ${BASE_TAG}"
          echo "  BASE_DIGEST:       ${BASE_DIGEST}"
          echo "  Base Image:        ${{ matrix.target.base.image }}"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ steps.prep.outputs.dockerfile }}
          platforms: ${{ steps.prep.outputs.platform }}
          push: true
          tags: ghcr.io/${{ github.repository }}:${{ steps.prep.outputs.image_tag }}
          provenance: false
          build-args: |
            BUILDER_TAG=${{ steps.prep.outputs.builder_tag }}
            BUILDER_DIGEST=${{ steps.prep.outputs.builder_digest }}
            BASE_TAG=${{ steps.prep.outputs.base_tag }}
            BASE_DIGEST=${{ steps.prep.outputs.base_digest }}
            VERSION=${{ steps.prep.outputs.version }}
            BUILD_DATE=${{ steps.prep.outputs.build_date }}
            GIT_COMMIT=${{ steps.prep.outputs.git_commit }}
          labels: |
            org.opencontainers.image.created=${{ steps.prep.outputs.label_created }}
            org.opencontainers.image.title=${{ steps.prep.outputs.label_title }}
            org.opencontainers.image.revision=${{ steps.prep.outputs.label_revision }}
            org.opencontainers.image.source=${{ steps.prep.outputs.label_source }}
            org.opencontainers.image.vendor=${{ steps.prep.outputs.label_vendor }}
            org.opencontainers.image.version=${{ steps.prep.outputs.label_version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  publish:
    needs: [build]
    if: success()
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_TOKEN }}
      
      - name: Extract variants and metadata
        id: prep
        run: |
          # Extract unique variants directly from target.variant field
          VARIANTS=$(jq -r '.targets[] | select(.enabled == true) | .variant' VERSION.json | sort -u)
          VERSION=$(jq -r '.version' VERSION.json)
          BRANCH="${{ github.ref_name }}"
          SHA="${{ github.sha }}"
          DEFAULT_BRANCH="${{ github.event.repository.default_branch }}"
          REPOSITORY="${{ github.repository }}"
          
          # Output for use in subsequent steps
          {
            echo "variants<<EOF"
            echo "$VARIANTS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "sha=${SHA}" >> $GITHUB_OUTPUT
          echo "default_branch=${DEFAULT_BRANCH}" >> $GITHUB_OUTPUT
          echo "repository=${REPOSITORY}" >> $GITHUB_OUTPUT
      
      - name: Create and push manifest lists
        uses: nick-fields/retry@v3
        env:
          VARIANTS: ${{ steps.prep.outputs.variants }}
          VERSION: ${{ steps.prep.outputs.version }}
          BRANCH: ${{ steps.prep.outputs.branch }}
          SHA: ${{ steps.prep.outputs.sha }}
          DEFAULT_BRANCH: ${{ steps.prep.outputs.default_branch }}
          REPOSITORY: ${{ steps.prep.outputs.repository }}
        with:
          max_attempts: 3
          timeout_minutes: 5
          retry_wait_seconds: 30
          command: |
            # For each variant, collect platform images and create manifest list
            echo "$VARIANTS" | while IFS= read -r variant; do
              echo "Processing variant: $variant"
              
              # Get all enabled targets for this variant
              TARGETS=$(jq -r --arg v "$variant" '.targets[] | select(.enabled == true and .variant == $v) | .name' VERSION.json)
              
              # Build image tag list and verify existence
              PLATFORM_IMAGES=()
              for target in $TARGETS; do
                IMAGE_TAG="ghcr.io/${REPOSITORY}:${BRANCH}-${VERSION}-${target}"
                if docker buildx imagetools inspect "$IMAGE_TAG" >/dev/null 2>&1; then
                  PLATFORM_IMAGES+=("$IMAGE_TAG")
                  echo "  âœ“ Found: $IMAGE_TAG"
                else
                  echo "  âœ— Missing: $IMAGE_TAG"
                fi
              done
              
              # Only create manifest if we have at least 2 platforms
              if [ ${#PLATFORM_IMAGES[@]} -lt 2 ]; then
                echo "Skipping manifest creation for $variant: only ${#PLATFORM_IMAGES[@]} platform(s) available"
                continue
              fi
              
              # Define primary tag (first tag becomes the manifest reference)
              PRIMARY_TAG="ghcr.io/${REPOSITORY}:${BRANCH}-${variant}"
              
              # Create manifest list once with primary tag
              echo "Creating manifest list: $PRIMARY_TAG"
              docker buildx imagetools create \
                --tag "$PRIMARY_TAG" \
                "${PLATFORM_IMAGES[@]}"
              
              # Create additional tags as aliases pointing to the same manifest
              # This is more efficient than creating separate manifests (matches Hotio pattern)
              echo "Creating tag alias: ${BRANCH}-${VERSION}-${variant}"
              docker buildx imagetools create \
                --tag "ghcr.io/${REPOSITORY}:${BRANCH}-${VERSION}-${variant}" \
                "$PRIMARY_TAG"
              
              echo "Creating tag alias: ${BRANCH}-${SHA:0:7}-${variant}"
              docker buildx imagetools create \
                --tag "ghcr.io/${REPOSITORY}:${BRANCH}-${SHA:0:7}-${variant}" \
                "$PRIMARY_TAG"
              
              echo "âœ“ Manifest list created for variant: $variant with all tag aliases"
            done

  tags:
    needs: [build, publish]
    if: success()
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout default branch
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.repository.default_branch || 'main' }}
          fetch-depth: 0
      
      - name: Update tags.json
        uses: nick-fields/retry@v3
        env:
          RUN_ID: ${{ github.run_id }}
          REPOSITORY: ${{ github.repository }}
          SERVER_URL: ${{ github.server_url }}
          BRANCH: ${{ needs.build.outputs.branch }}
          VERSION: ${{ needs.build.outputs.version }}
          SHA: ${{ needs.build.outputs.sha }}
          IMAGE_TAG_BRANCH: ${{ needs.build.outputs.image_tag_branch }}
          IMAGE_TAG_BRANCH_VERSION: ${{ needs.build.outputs.image_tag_branch_version }}
          IMAGE_TAG_BRANCH_SHA: ${{ needs.build.outputs.image_tag_branch_sha }}
        with:
          max_attempts: 3
          timeout_minutes: 5
          retry_wait_seconds: 30
          command: |
            set -e
            
            # Pull latest changes to handle concurrent updates
            git pull --rebase || true
            
            # Create tags.json if it doesn't exist
            [ ! -f tags.json ] && echo '{}' > tags.json
            
            # Extract branch name without repository prefix for tags.json key
            BRANCH_KEY="${BRANCH}"
            IMAGE_TAG_BRANCH_CLEAN="${IMAGE_TAG_BRANCH/$REPOSITORY:/}"
            IMAGE_TAG_BRANCH_VERSION_CLEAN="${IMAGE_TAG_BRANCH_VERSION/$REPOSITORY:/}"
            IMAGE_TAG_BRANCH_SHA_CLEAN="${IMAGE_TAG_BRANCH_SHA/$REPOSITORY:/}"
            
            # Generate timestamp
            TIMESTAMP=$(date -u +'%Y-%m-%dT%H:%M:%S.000Z')
            BUILD_URL="${SERVER_URL}/${REPOSITORY}/actions/runs/${RUN_ID}"
            
            # Update tags.json using jq
            jq --sort-keys \
                --arg branch "${BRANCH_KEY}" \
                --arg image_tag_branch "${IMAGE_TAG_BRANCH_CLEAN}" \
                --arg image_tag_branch_version "${IMAGE_TAG_BRANCH_VERSION_CLEAN}" \
                --arg image_tag_branch_sha "${IMAGE_TAG_BRANCH_SHA_CLEAN}" \
                --arg last_updated "${TIMESTAMP}" \
                --arg last_updated_url "${BUILD_URL}" \
                --arg description "${BRANCH_KEY}" \
                --argjson hide false \
                '.[$branch] = {
                  "description": $description,
                  "hide": $hide,
                  "last_updated": $last_updated,
                  "last_updated_url": $last_updated_url,
                  "tags": [$image_tag_branch, $image_tag_branch_version, $image_tag_branch_sha]
                }' tags.json > tags.json.tmp && mv tags.json.tmp tags.json
            
            # Only commit if tags.json actually changed
            if ! git diff --quiet tags.json; then
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git add tags.json
              git commit -m "Update tags.json for ${BRANCH_KEY} branch (version: ${VERSION}) [skip ci]" || exit 0
              git push || { echo "Error: Failed to push tags.json update"; exit 1; }
            else
              echo "No changes to tags.json, skipping commit"
            fi
          new_command_on_retry: |
            git pull --rebase
            git push