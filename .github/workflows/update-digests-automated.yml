name: update-digests-automated

on:
  workflow_dispatch:
  schedule:
    - cron: '0 * * * *'

jobs:
  do-work:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    concurrency:
      group: update-digests-automated
      cancel-in-progress: false
    
    steps:
      - name: Git Config
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Do Work
        env:
          REPOSITORY_OWNER: runlix
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_ACTOR: ${{ github.actor }}
        run: |
          set -e
          
          if [ -z "${GH_TOKEN:-}" ]; then
            echo "ERROR: GITHUB_TOKEN is not set"
            exit 1
          fi
          
          while IFS= read -r REPOSITORY; do
            [ -z "$REPOSITORY" ] && continue
            
            while IFS= read -r BRANCH; do
              [ -z "$BRANCH" ] && continue
              
              CLONE_DIR=$(mktemp -d)
              
              # Clone without token first (for public repos), then configure remote with token for push
              if ! git clone -b "${BRANCH}" "https://github.com/${REPOSITORY_OWNER}/${REPOSITORY}.git" "${CLONE_DIR}" 2>/dev/null; then
                # If public clone fails, try with token (for private repos)
                if ! git clone -b "${BRANCH}" "https://${GH_TOKEN}@github.com/${REPOSITORY_OWNER}/${REPOSITORY}.git" "${CLONE_DIR}" 2>/dev/null; then
                  echo "Failed to clone ${REPOSITORY}:${BRANCH}"
                  rm -rf "${CLONE_DIR}"
                  continue
                fi
              fi
              
              cd "${CLONE_DIR}" || { rm -rf "${CLONE_DIR}"; continue; }
              
              # Configure remote with token for push operations (set once)
              git remote set-url origin "https://${GH_TOKEN}@github.com/${REPOSITORY_OWNER}/${REPOSITORY}.git" 2>/dev/null || true
              
              if [ ! -f update-digests.sh ]; then
                cd .. || exit 1
                rm -rf "${CLONE_DIR}"
                continue
              fi
              
              bash ./update-digests.sh || { cd .. || exit 1; rm -rf "${CLONE_DIR}"; continue; }
              
              COMMIT_MESSAGE="Upstream image update"
              [ "${BRANCH}" = "pr" ] && COMMIT_MESSAGE="Upstream image update [skip ci]"
              
              git add .
              
              if ! git diff --quiet || ! git diff --cached --quiet; then
                PR_BRANCH="update-digests-${GITHUB_RUN_ID}-$(date +%s)"
                git checkout -b "${PR_BRANCH}" || { cd .. || exit 1; rm -rf "${CLONE_DIR}"; continue; }
                git commit -m "${COMMIT_MESSAGE}" || { cd .. || exit 1; rm -rf "${CLONE_DIR}"; continue; }
                git push -u origin "${PR_BRANCH}" || { cd .. || exit 1; rm -rf "${CLONE_DIR}"; continue; }
                
                gh pr create \
                  --repo "${REPOSITORY_OWNER}/${REPOSITORY}" \
                  --title "Upstream image update" \
                  --body "Automated upstream image digest update for branch \`${BRANCH}\`" \
                  --base "${BRANCH}" \
                  --head "${PR_BRANCH}" \
                  --label "automated,dependencies" || true
              fi
              
              cd .. || exit 1
              rm -rf "${CLONE_DIR}"
            done < <(curl -u "${GH_ACTOR}:${GH_TOKEN}" -fsSL "https://api.github.com/repos/${REPOSITORY_OWNER}/${REPOSITORY}/branches" 2>/dev/null | jq -r '.[] | select(.name!="main" and .name!="master") | .name' || true)
          done < <(curl -u "${GH_ACTOR}:${GH_TOKEN}" -fsSL "https://api.github.com/users/${REPOSITORY_OWNER}/repos?per_page=1000" 2>/dev/null | jq -r '.[] | select(.topics[]?=="docker-image") | .name' || true)
