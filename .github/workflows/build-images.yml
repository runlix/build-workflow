# Reusable Workflow for Multi-Architecture Docker Image Builds
# This workflow is called by service repositories for PR validation and releases
#
# Usage from service repository:
#   uses: runlix/build-workflow/.github/workflows/build-images.yml@main
#   with:
#     pr_mode: true  # or false for release mode
#     dry_run: false # optional, skip push for testing

name: Build Multi-Arch Images

on:
  workflow_call:
    inputs:
      pr_mode:
        description: 'PR validation mode (true) or release mode (false)'
        required: true
        type: boolean
      dry_run:
        description: 'Skip image push to registry (for testing)'
        required: false
        type: boolean
        default: false
    secrets:
      RUNLIX_APP_ID:
        description: 'GitHub App ID for authenticated operations'
        required: true
      RUNLIX_PRIVATE_KEY:
        description: 'GitHub App private key for authenticated operations'
        required: true

# Workflow-level environment variables
env:
  REGISTRY: ghcr.io
  REGISTRY_ORG: runlix

# Permissions required by this workflow
# Note: Calling workflow must grant these permissions via 'secrets: inherit'
permissions:
  contents: write       # Update releases.json in main branch (release mode only)
  packages: write       # Push images to GHCR, delete platform tags
  pull-requests: write  # Comment on PR with build results (PR mode only)
  actions: read         # Query workflow artifacts and PR status

jobs:
  # Job 1: Parse and validate docker-matrix.json
  # Expands variants √ó platforms into matrix for parallel builds
  parse-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.expand.outputs.matrix }}
      version: ${{ steps.extract.outputs.version }}
    steps:
      - name: Checkout calling repository
        uses: actions/checkout@v4
        with:
          # For PR mode: checkout PR head SHA
          # For release mode: checkout release branch
          ref: ${{ inputs.pr_mode && github.event.pull_request.head.sha || github.ref }}

      - name: Setup Node.js for schema validation
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install ajv-cli for schema validation
        run: npm install -g ajv-cli ajv-formats

      - name: Validate schema
        run: |
          echo "üìã Validating docker-matrix.json against schema..."

          # Download schema from this repository
          curl -sSL https://raw.githubusercontent.com/runlix/build-workflow/main/schema/docker-matrix-schema.json -o /tmp/schema.json

          # Validate with clear error messages
          if ! ajv validate -s /tmp/schema.json -d .ci/docker-matrix.json --strict=false; then
            echo "‚ùå ERROR: docker-matrix.json validation failed"
            echo "Please ensure your configuration matches the schema at:"
            echo "https://github.com/runlix/build-workflow/blob/main/schema/docker-matrix-schema.json"
            exit 1
          fi

          echo "‚úÖ Schema validation passed"

      - name: Extract top-level fields
        id: extract
        run: |
          echo "üìã Extracting top-level fields from docker-matrix.json..."

          # Extract version (optional)
          VERSION=$(jq -r '.version // ""' .ci/docker-matrix.json)
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          # Extract base_image fields (optional, for services)
          BASE_IMAGE=$(jq -r '.base_image.image // ""' .ci/docker-matrix.json)
          BASE_TAG=$(jq -r '.base_image.tag // ""' .ci/docker-matrix.json)
          BASE_DIGEST=$(jq -r '.base_image.digest // ""' .ci/docker-matrix.json)

          echo "base_image=$BASE_IMAGE" >> $GITHUB_OUTPUT
          echo "base_tag=$BASE_TAG" >> $GITHUB_OUTPUT
          echo "base_digest=$BASE_DIGEST" >> $GITHUB_OUTPUT

          # Log extracted values
          if [ -n "$VERSION" ]; then
            echo "Version: $VERSION"
          else
            echo "No version field (will use SHA-based versioning)"
          fi

          if [ -n "$BASE_IMAGE" ]; then
            echo "Base image: $BASE_IMAGE:$BASE_TAG@$BASE_DIGEST"
          else
            echo "No base_image (this is a base image repository)"
          fi

      - name: Validate variants
        run: |
          echo "üìã Validating variant configuration..."

          # Check at least one enabled variant exists
          ENABLED_COUNT=$(jq '[.variants[] | select(.enabled // true == true)] | length' .ci/docker-matrix.json)
          if [ "$ENABLED_COUNT" -eq 0 ]; then
            echo "‚ùå ERROR: No enabled variants found"
            echo "At least one variant must have 'enabled: true' or omit the enabled field"
            exit 1
          fi
          echo "‚úÖ Found $ENABLED_COUNT enabled variant(s)"

          # Check variant name uniqueness
          DUPLICATE_NAMES=$(jq -r '.variants[].name' .ci/docker-matrix.json | sort | uniq -d)
          if [ -n "$DUPLICATE_NAMES" ]; then
            echo "‚ùå ERROR: Duplicate variant names found:"
            echo "$DUPLICATE_NAMES"
            exit 1
          fi
          echo "‚úÖ All variant names are unique"

      - name: Validate platform-Dockerfile mapping
        run: |
          echo "üìã Validating platform-Dockerfile mappings..."

          # Check each variant's platforms have corresponding Dockerfiles
          jq -c '.variants[] | select(.enabled // true == true)' .ci/docker-matrix.json | while read variant; do
            VARIANT_NAME=$(echo "$variant" | jq -r '.name')
            echo "Checking variant: $VARIANT_NAME"

            # Check each platform has a Dockerfile
            echo "$variant" | jq -r '.platforms[]' | while read platform; do
              DOCKERFILE=$(echo "$variant" | jq -r --arg p "$platform" '.dockerfiles[$p]')

              if [ "$DOCKERFILE" == "null" ] || [ -z "$DOCKERFILE" ]; then
                echo "‚ùå ERROR: Variant '$VARIANT_NAME' platform '$platform' missing Dockerfile mapping"
                exit 1
              fi

              # Check if Dockerfile exists
              if [ ! -f "$DOCKERFILE" ]; then
                echo "‚ùå ERROR: Dockerfile not found: $DOCKERFILE"
                echo "Required by variant '$VARIANT_NAME' platform '$platform'"
                exit 1
              fi

              echo "  ‚úÖ $platform ‚Üí $DOCKERFILE"
            done
          done

          echo "‚úÖ All platform-Dockerfile mappings valid"

      - name: Expand matrix with auto-injection
        id: expand
        run: |
          echo "üìã Expanding matrix with auto-injection of BASE_* args..."

          # Get base_image fields for auto-injection
          BASE_IMAGE="${{ steps.extract.outputs.base_image }}"
          BASE_TAG="${{ steps.extract.outputs.base_tag }}"
          BASE_DIGEST="${{ steps.extract.outputs.base_digest }}"

          # Expand variants √ó platforms into matrix
          # Auto-inject BASE_IMAGE, BASE_TAG (with tag_suffix appended), BASE_DIGEST
          MATRIX=$(jq -c \
            --arg base_img "$BASE_IMAGE" \
            --arg base_tag "$BASE_TAG" \
            --arg base_digest "$BASE_DIGEST" '
            [
              .variants[]
              | select(.enabled // true == true)
              | .platforms[] as $platform
              | {
                  variant_name: .name,
                  platform: $platform,
                  arch: ($platform | split("/")[1]),
                  dockerfile: .dockerfiles[$platform],
                  tag_suffix: .tag_suffix,
                  test_script: (.test_script // ""),
                  build_args: (
                    .build_args +
                    (if $base_img != "" then {
                      BASE_IMAGE: $base_img,
                      BASE_TAG: ($base_tag + "-" + .tag_suffix),
                      BASE_DIGEST: $base_digest
                    } else {} end)
                  )
                }
            ]
          ' .ci/docker-matrix.json)

          # Set matrix output
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT

          # Log matrix size and details
          MATRIX_SIZE=$(echo "$MATRIX" | jq 'length')
          echo "‚úÖ Matrix expanded: $MATRIX_SIZE jobs"
          echo ""
          echo "Matrix jobs:"
          echo "$MATRIX" | jq -r '.[] | "  - \(.variant_name) / \(.arch)"'

      - name: Log disabled variants
        run: |
          DISABLED=$(jq -r '.variants[] | select(.enabled == false) | "‚ö†Ô∏è  Skipping disabled variant: \(.name)"' .ci/docker-matrix.json)
          if [ -n "$DISABLED" ]; then
            echo "$DISABLED"
          else
            echo "No disabled variants"
          fi

      - name: Log version type
        run: |
          VERSION="${{ steps.extract.outputs.version }}"
          if [ -n "$VERSION" ]; then
            echo "üì¶ Release mode: Versioned tags ($VERSION)"
          else
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            echo "üì¶ Release mode: SHA-based tags ($SHORT_SHA)"
          fi

  # Job 2: Promote or build images (matrix strategy)
  # Runs in parallel for each variant+platform combination
  # PR mode: Build, test, and push
  # Release mode: Promote from PR images or rebuild if not found
  promote-or-build:
    needs: parse-matrix
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      fail-fast: true
      matrix:
        include: ${{ fromJson(needs.parse-matrix.outputs.matrix) }}
    env:
      SERVICE_NAME: ${{ github.event.repository.name }}
    steps:
      - name: Checkout calling repository
        uses: actions/checkout@v4

      - name: Setup crane
        if: ${{ !inputs.pr_mode }}
        uses: imjasonh/setup-crane@v0.1

      - name: Find merged PR and workflow run
        id: find-pr
        if: ${{ !inputs.pr_mode }}
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)

          echo "Searching for merged PR containing commit ${{ github.sha }}..."

          # Search for merged PR
          PR_DATA=$(gh pr list \
            --search "${{ github.sha }}" \
            --state merged \
            --json number,headRefOid \
            --jq '.[0] // empty')

          if [ -n "$PR_DATA" ]; then
            PR_NUM=$(echo "$PR_DATA" | jq -r '.number')
            PR_HEAD_SHA=$(echo "$PR_DATA" | jq -r '.headRefOid')
            PR_HEAD_SHORT=$(echo "$PR_HEAD_SHA" | cut -c1-7)

            echo "‚úÖ Found merged PR #$PR_NUM"
            echo "  Merge commit: ${{ github.sha }} ($SHORT_SHA)"
            echo "  PR head commit: $PR_HEAD_SHA ($PR_HEAD_SHORT)"

            # Find the most recent successful PR validation workflow run for this PR
            echo ""
            echo "Searching for PR validation workflow run..."
            WORKFLOW_RUN=$(gh run list \
              --workflow=pr-validation.yml \
              --json databaseId,conclusion,headSha \
              --jq ".[] | select(.headSha | startswith(\"$PR_HEAD_SHA\")) | select(.conclusion == \"success\") | .databaseId" | \
              head -n1)

            if [ -n "$WORKFLOW_RUN" ]; then
              echo "‚úÖ Found workflow run: $WORKFLOW_RUN"
              echo "workflow_run_id=$WORKFLOW_RUN" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è  No successful PR validation workflow run found"
            fi

            echo "pr_number=$PR_NUM" >> $GITHUB_OUTPUT
            echo "pr_head_sha=$PR_HEAD_SHA" >> $GITHUB_OUTPUT
            echo "pr_head_short=$PR_HEAD_SHORT" >> $GITHUB_OUTPUT
            echo "found=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è  No merged PR found for this commit"
            echo "Will rebuild from scratch"
            echo "found=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Download PR build manifest
        id: download-manifest
        if: ${{ !inputs.pr_mode && steps.find-pr.outputs.found == 'true' && steps.find-pr.outputs.workflow_run_id != '' }}
        continue-on-error: true
        run: |
          WORKFLOW_RUN_ID="${{ steps.find-pr.outputs.workflow_run_id }}"

          echo "Downloading build manifest from workflow run: $WORKFLOW_RUN_ID"

          # Download the build-manifest artifact from the PR workflow run
          gh run download "$WORKFLOW_RUN_ID" \
            --name build-manifest \
            --dir pr-manifest/

          if [ -f pr-manifest/manifest.json ]; then
            echo "‚úÖ Downloaded manifest.json"
            cat pr-manifest/manifest.json | jq .
            echo "manifest_found=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è  manifest.json not found in artifact"
            echo "manifest_found=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for PR image
        id: check-pr-image
        if: ${{ !inputs.pr_mode && steps.find-pr.outputs.found == 'true' }}
        run: |
          # Try to find exact image from PR manifest first
          if [ "${{ steps.download-manifest.outputs.manifest_found }}" == "true" ]; then
            echo "Looking for image in PR manifest..."

            # Extract images for this variant and arch from manifest
            # Manifest format: {pr_number, commit_sha, timestamp, images: ["image@digest", ...]}
            IMAGE_REF=$(jq -r --arg variant "${{ matrix.tag_suffix }}" \
                              --arg arch "${{ matrix.arch }}" \
              '.images[] | select(contains($variant) and contains($arch))' \
              pr-manifest/manifest.json | head -n1)

            if [ -n "$IMAGE_REF" ]; then
              # Extract tag from full image reference
              # Format: registry/org/repo:tag@sha256:digest
              # We want just the "tag" part
              PR_TAG=$(echo "$IMAGE_REF" | sed 's|^[^:]*:||' | cut -d'@' -f1)

              echo "‚úÖ Found exact PR image from manifest: $PR_TAG"
              echo "  Full reference: $IMAGE_REF"

              # Verify image still exists
              if crane digest "$IMAGE_REF" > /dev/null 2>&1; then
                echo "‚úÖ Image verified in registry"
                echo "exists=true" >> $GITHUB_OUTPUT
                echo "pr_tag=$PR_TAG" >> $GITHUB_OUTPUT
              else
                echo "‚ö†Ô∏è  Image from manifest no longer exists in registry"
                echo "exists=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "‚ö†Ô∏è  No matching image found in manifest for ${{ matrix.tag_suffix }}-${{ matrix.arch }}"
              echo "exists=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è  No PR manifest available"
            echo "Cannot verify exact images, will rebuild from scratch"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate release tag
        id: release-tag
        if: ${{ !inputs.pr_mode }}
        run: |
          VERSION="${{ needs.parse-matrix.outputs.version }}"
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)

          # Generate platform tag (temporary)
          # Format: <version>-<suffix>-<arch>-<sha> or <suffix>-<arch>-<sha>
          if [ -n "$VERSION" ]; then
            PLATFORM_TAG="${VERSION}-${{ matrix.tag_suffix }}-${{ matrix.arch }}-${SHORT_SHA}"
            echo "Platform tag (versioned): $PLATFORM_TAG"
          else
            # Base images without version use SHA at end
            PLATFORM_TAG="${{ matrix.tag_suffix }}-${{ matrix.arch }}-${SHORT_SHA}"
            echo "Platform tag (SHA-based): $PLATFORM_TAG"
          fi

          echo "platform_tag=$PLATFORM_TAG" >> $GITHUB_OUTPUT

      - name: Promote PR image (fast path)
        id: promote
        if: ${{ !inputs.pr_mode && steps.check-pr-image.outputs.exists == 'true' }}
        run: |
          SRC_TAG="${{ steps.check-pr-image.outputs.pr_tag }}"
          DST_TAG="${{ steps.release-tag.outputs.platform_tag }}"

          SRC="${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:${SRC_TAG}"
          DST="${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:${DST_TAG}"

          echo "üì¶ Promoting PR image to release"
          echo "  Source: $SRC_TAG"
          echo "  Destination: $DST_TAG"

          # Copy image (preserves digest, very fast - registry-to-registry)
          crane copy "$SRC" "$DST"

          echo "‚úÖ Promoted successfully in ~30 seconds (no rebuild needed)"
          echo "promoted=true" >> $GITHUB_OUTPUT

      - name: Set up QEMU
        if: inputs.pr_mode || steps.promote.outputs.promoted != 'true'
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: inputs.pr_mode || steps.promote.outputs.promoted != 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        if: ${{ !inputs.dry_run }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: buildx-${{ matrix.variant_name }}-${{ matrix.platform }}-${{ github.sha }}
          restore-keys: |
            buildx-${{ matrix.variant_name }}-${{ matrix.platform }}-

      - name: Generate image tag
        id: tag
        if: inputs.pr_mode || steps.promote.outputs.promoted != 'true'
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)

          if ${{ inputs.pr_mode }}; then
            # PR mode: pr-<pr_number>-<version>-<suffix>-<arch>-<sha>
            PR_NUM=${{ github.event.pull_request.number }}
            VERSION="${{ needs.parse-matrix.outputs.version }}"

            if [ -n "$VERSION" ]; then
              IMAGE_TAG="${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:pr-${PR_NUM}-${VERSION}-${{ matrix.tag_suffix }}-${{ matrix.arch }}-${SHORT_SHA}"
            else
              IMAGE_TAG="${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:pr-${PR_NUM}-${{ matrix.tag_suffix }}-${{ matrix.arch }}-${SHORT_SHA}"
            fi
          else
            # Release mode rebuild: use platform tag from release-tag step
            PLATFORM_TAG="${{ steps.release-tag.outputs.platform_tag }}"
            IMAGE_TAG="${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:${PLATFORM_TAG}"
          fi

          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "üî® Building: $IMAGE_TAG"

      - name: Build image with OCI labels
        if: inputs.pr_mode || steps.promote.outputs.promoted != 'true'
        run: |
          VERSION="${{ needs.parse-matrix.outputs.version }}"
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Expand build_args from matrix (already includes auto-injected BASE_*)
          BUILD_ARGS=$(echo '${{ toJson(matrix.build_args) }}' | jq -r 'to_entries[] | "--build-arg \(.key)=\(.value)"' | tr '\n' ' ')

          # Build with OCI labels
          docker buildx build \
            --platform ${{ matrix.platform }} \
            -f ${{ matrix.dockerfile }} \
            $BUILD_ARGS \
            --label "org.opencontainers.image.revision=${{ github.sha }}" \
            --label "org.opencontainers.image.created=${BUILD_DATE}" \
            --label "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
            $([ -n "$VERSION" ] && echo "--label org.opencontainers.image.version=$VERSION" || echo "") \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
            --load \
            -t $IMAGE_TAG \
            .

          echo "‚úÖ Built: $IMAGE_TAG"

      - name: Run tests
        if: |
          matrix.test_script != '' &&
          (inputs.pr_mode || steps.promote.outputs.promoted != 'true')
        timeout-minutes: 10
        run: |
          echo "Running test script: ${{ matrix.test_script }}"
          chmod +x ${{ matrix.test_script }}
          ${{ matrix.test_script }}
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}

      - name: Scan for vulnerabilities
        if: inputs.pr_mode || steps.promote.outputs.promoted != 'true'
        uses: aquasecurity/trivy-action@master
        continue-on-error: true
        with:
          image-ref: ${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: 'trivy-results-${{ matrix.variant_name }}-${{ matrix.arch }}.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Push image with retry
        if: |
          !inputs.dry_run &&
          (inputs.pr_mode || steps.promote.outputs.promoted != 'true')
        uses: nick-fields/retry@v2
        with:
          timeout_minutes: 10
          max_attempts: 3
          retry_wait_seconds: 10
          command: docker push ${{ env.IMAGE_TAG }}

      - name: Save platform tag for manifest creation
        if: ${{ !inputs.pr_mode && success() }}
        run: |
          PLATFORM_TAG="${{ steps.release-tag.outputs.platform_tag }}"
          FILENAME="platform-tag-${{ matrix.variant_name }}-${{ matrix.arch }}.txt"

          echo "üì¶ Saving platform tag for manifest creation: $PLATFORM_TAG"
          echo "$PLATFORM_TAG" > "$FILENAME"

      - name: Upload platform tag artifact
        if: ${{ !inputs.pr_mode && success() }}
        uses: actions/upload-artifact@v4
        with:
          name: platform-tag-${{ matrix.variant_name }}-${{ matrix.arch }}
          path: platform-tag-${{ matrix.variant_name }}-${{ matrix.arch }}.txt
          retention-days: 1

      - name: Report failure to PR
        if: failure() && inputs.pr_mode
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚ùå **Build Failed**: ${{ matrix.variant_name }} / ${{ matrix.arch }}\n\n` +
                    `**Platform**: \`${{ matrix.platform }}\`\n` +
                    `**Dockerfile**: \`${{ matrix.dockerfile }}\`\n\n` +
                    `[View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`
            })

      - name: Upload failure artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: failure-${{ matrix.variant_name }}-${{ matrix.arch }}
          path: |
            trivy-results-${{ matrix.variant_name }}-${{ matrix.arch }}.sarif
          retention-days: 7

      - name: Capture image digest
        if: success()
        id: digest
        run: |
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ env.IMAGE_TAG }} | cut -d'@' -f2)
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "${{ env.IMAGE_TAG }}@$DIGEST" > image-manifest.txt
          echo "Image: ${{ env.IMAGE_TAG }}@$DIGEST"

      - name: Upload manifest fragment
        if: success() && inputs.pr_mode
        uses: actions/upload-artifact@v4
        with:
          name: manifest-${{ matrix.variant_name }}-${{ matrix.arch }}
          path: image-manifest.txt

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

  # Job 3: Collect results and create summary
  # Posts PR comments, generates manifest artifacts
  summary:
    needs: [parse-matrix, promote-or-build]
    runs-on: ubuntu-latest
    if: always()  # Run even if builds fail to report results
    env:
      SERVICE_NAME: ${{ github.event.repository.name }}
    steps:
      - name: Checkout calling repository
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: List downloaded artifacts
        run: |
          echo "üì¶ Downloaded artifacts:"
          ls -R artifacts/

      - name: Generate consolidated manifest
        id: manifest
        run: |
          echo "üìã Generating consolidated manifest..."

          # Collect all image references
          IMAGES="[]"
          if [ -d "artifacts" ]; then
            for fragment in artifacts/manifest-*/image-manifest.txt; do
              if [ -f "$fragment" ]; then
                IMAGE_REF=$(cat "$fragment")
                echo "  Found: $IMAGE_REF"
                IMAGES=$(echo "$IMAGES" | jq --arg ref "$IMAGE_REF" '. += [$ref]')
              fi
            done
          fi

          # Create manifest with metadata (PR mode only)
          if ${{ inputs.pr_mode }}; then
            PR_NUM=${{ github.event.pull_request.number }}
            TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

            jq -n \
              --arg pr "$PR_NUM" \
              --arg sha "${{ github.sha }}" \
              --arg timestamp "$TIMESTAMP" \
              --argjson images "$IMAGES" \
              '{
                pr_number: ($pr | tonumber),
                commit_sha: $sha,
                timestamp: $timestamp,
                images: $images
              }' > manifest.json
          else
            # Release mode: simple array for compatibility
            echo "$IMAGES" > manifest.json
          fi

          # Count images
          if ${{ inputs.pr_mode }}; then
            IMAGE_COUNT=$(jq '.images | length' manifest.json)
          else
            IMAGE_COUNT=$(jq 'length' manifest.json)
          fi
          echo "image_count=$IMAGE_COUNT" >> $GITHUB_OUTPUT

          echo "‚úÖ Manifest generated with $IMAGE_COUNT images"
          cat manifest.json

      - name: Parse vulnerability results
        id: vulns
        if: always()
        continue-on-error: true
        run: |
          echo "üîç Parsing vulnerability scan results..."

          # Count SARIF files
          VULN_COUNT=0
          CRITICAL_COUNT=0
          HIGH_COUNT=0
          MEDIUM_COUNT=0

          if [ -d "artifacts" ]; then
            VULN_COUNT=$(find artifacts/ -name "trivy-results-*.sarif" 2>/dev/null | wc -l)

            # Parse each SARIF file for CVE counts by severity
            for sarif in artifacts/failure-*/trivy-results-*.sarif; do
              if [ -f "$sarif" ]; then
                # Count by severity level
                # SARIF format: .runs[].results[] with .level property
                CRITICAL=$(jq '[.runs[].results[]? | select(.level=="error" and (.properties."security-severity"? // "0" | tonumber) >= 9.0)] | length' "$sarif" 2>/dev/null || echo "0")
                HIGH=$(jq '[.runs[].results[]? | select(.level=="error" and (.properties."security-severity"? // "0" | tonumber) >= 7.0 and (.properties."security-severity"? // "0" | tonumber) < 9.0)] | length' "$sarif" 2>/dev/null || echo "0")
                MEDIUM=$(jq '[.runs[].results[]? | select(.level=="warning")] | length' "$sarif" 2>/dev/null || echo "0")

                CRITICAL_COUNT=$((CRITICAL_COUNT + CRITICAL))
                HIGH_COUNT=$((HIGH_COUNT + HIGH))
                MEDIUM_COUNT=$((MEDIUM_COUNT + MEDIUM))
              fi
            done
          fi

          echo "vuln_file_count=$VULN_COUNT" >> $GITHUB_OUTPUT
          echo "critical_count=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
          echo "high_count=$HIGH_COUNT" >> $GITHUB_OUTPUT
          echo "medium_count=$MEDIUM_COUNT" >> $GITHUB_OUTPUT

          echo "Found $VULN_COUNT vulnerability scan(s)"
          echo "  Critical: $CRITICAL_COUNT"
          echo "  High: $HIGH_COUNT"
          echo "  Medium: $MEDIUM_COUNT"

      - name: Check build status
        id: status
        run: |
          # Check if promote-or-build job succeeded
          if [ "${{ needs.promote-or-build.result }}" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "status_emoji=‚úÖ" >> $GITHUB_OUTPUT
            echo "status_text=All builds succeeded" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "status_emoji=‚ùå" >> $GITHUB_OUTPUT
            echo "status_text=Some builds failed" >> $GITHUB_OUTPUT
          fi

      - name: Generate PR comment body
        if: inputs.pr_mode
        id: comment
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          PR_NUM=${{ github.event.pull_request.number }}
          IMAGE_COUNT=${{ steps.manifest.outputs.image_count }}

          # Build comment body
          cat > comment.md <<'EOF'
          ${{ steps.status.outputs.status_emoji }} **Docker Build Report**

          **Status**: ${{ steps.status.outputs.status_text }}
          **PR**: #${{ github.event.pull_request.number }}
          **Commit**: `${{ github.sha }}`
          **Images Built**: ${{ steps.manifest.outputs.image_count }}

          ---

          ### Built Images

          EOF

          # Add image list from manifest
          if [ -f "manifest.json" ] && [ "$IMAGE_COUNT" -gt 0 ]; then
            echo "The following images were built and pushed to GHCR:" >> comment.md
            echo "" >> comment.md
            # PR mode has structured manifest with .images field
            jq -r '.images[] | "- `\(.)`"' manifest.json >> comment.md
          else
            echo "No images were successfully built." >> comment.md
          fi

          # Add vulnerability scan info
          VULN_COUNT=${{ steps.vulns.outputs.vuln_file_count }}
          CRITICAL=${{ steps.vulns.outputs.critical_count }}
          HIGH=${{ steps.vulns.outputs.high_count }}
          MEDIUM=${{ steps.vulns.outputs.medium_count }}

          if [ "$VULN_COUNT" -gt 0 ]; then
            cat >> comment.md <<VULNEOF

          ---

          ### Security Scans

          üîç Vulnerability scans completed for $VULN_COUNT image(s).

          **Vulnerabilities Found:**
          - üî¥ Critical: $CRITICAL
          - üü† High: $HIGH
          - üü° Medium: $MEDIUM

          [View SARIF Results](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          VULNEOF
          fi

          # Add workflow link
          cat >> comment.md <<'LINKEOF'

          ---

          [View Full Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          LINKEOF

          echo "‚úÖ Generated PR comment"
          cat comment.md

      - name: Post PR comment
        if: inputs.pr_mode
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const commentBody = fs.readFileSync('comment.md', 'utf8');

            // Find existing comment from this workflow
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Docker Build Report')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
              console.log('Updated existing PR comment');
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
              console.log('Created new PR comment');
            }

      - name: Upload consolidated manifest
        if: inputs.pr_mode && steps.manifest.outputs.image_count > 0
        uses: actions/upload-artifact@v4
        with:
          name: build-manifest
          path: manifest.json
          retention-days: 90

      - name: Release mode summary
        if: ${{ !inputs.pr_mode }}
        run: |
          echo "üöÄ Release Summary"
          echo "=================="
          echo ""
          echo "Service: $SERVICE_NAME"

          VERSION="${{ needs.parse-matrix.outputs.version }}"
          if [ -n "$VERSION" ]; then
            echo "Version: $VERSION"
          else
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            echo "Version: $SHORT_SHA (SHA-based)"
          fi

          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "Platform images will be collected by create-manifests job"
          echo "Manifests will be created after all platforms complete"

      - name: Summary output
        run: |
          echo "üìä Build Summary"
          echo "================"
          echo "Status: ${{ steps.status.outputs.status_text }}"
          echo "Images: ${{ steps.manifest.outputs.image_count }}"
          echo "Vulnerability Scans: ${{ steps.vulns.outputs.vuln_file_count }}"
          echo ""

          if [ "${{ steps.status.outputs.status }}" == "failure" ]; then
            echo "‚ö†Ô∏è  Some builds failed. Check the logs above for details."
            exit 1
          fi

  # Job 4: Create multi-arch manifests (release mode only)
  # Collects platform tags and creates permanent manifest lists
  create-manifests:
    needs: [parse-matrix, promote-or-build]
    if: ${{ !inputs.pr_mode }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      SERVICE_NAME: ${{ github.event.repository.name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup crane
        uses: imjasonh/setup-crane@v0.1

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download platform tags
        uses: actions/download-artifact@v4
        with:
          pattern: platform-tag-*
          path: platform-tags/
          merge-multiple: true

      - name: List downloaded artifacts
        run: |
          echo "üì¶ Downloaded platform tags:"
          ls -la platform-tags/

      - name: Create multi-arch manifests
        id: manifests
        run: |
          VERSION="${{ needs.parse-matrix.outputs.version }}"
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)

          # Extract unique variants from matrix
          VARIANTS=$(echo '${{ needs.parse-matrix.outputs.matrix }}' | \
            jq -r '[.[] | {name: .variant_name, suffix: .tag_suffix, default: .is_default}] | unique_by(.name)')

          echo "üî® Creating manifests for variants:"
          echo "$VARIANTS" | jq -r '.[] | "  - \(.name) (suffix: \"\(.suffix)\", default: \(.default))"'
          echo ""

          # Create manifests-created.txt for tracking
          touch manifests-created.txt

          # For each variant
          echo "$VARIANTS" | jq -c '.[]' | while read variant; do
            VARIANT_NAME=$(echo "$variant" | jq -r '.name')
            TAG_SUFFIX=$(echo "$variant" | jq -r '.suffix')
            IS_DEFAULT=$(echo "$variant" | jq -r '.default')

            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "Variant: $VARIANT_NAME"
            echo ""

            # Determine manifest tag
            # Format: <version>-<suffix> or <suffix>
            if [ -n "$VERSION" ]; then
              MANIFEST_TAG="${VERSION}-${TAG_SUFFIX}"
            else
              MANIFEST_TAG="${TAG_SUFFIX}"
            fi

            echo "Target manifest tag: $MANIFEST_TAG"

            # Collect platform images for this variant
            PLATFORM_IMAGES=()
            for tag_file in platform-tags/platform-tag-${VARIANT_NAME}-*.txt; do
              if [ -f "$tag_file" ]; then
                PLATFORM_TAG=$(cat "$tag_file")
                FULL_IMAGE="${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:${PLATFORM_TAG}"
                PLATFORM_IMAGES+=("$FULL_IMAGE")
                echo "  + Platform: $PLATFORM_TAG"
              fi
            done

            if [ ${#PLATFORM_IMAGES[@]} -eq 0 ]; then
              echo "‚ùå Error: No platform images found for variant $VARIANT_NAME"
              exit 1
            fi

            echo ""
            echo "Creating multi-arch manifest with ${#PLATFORM_IMAGES[@]} platform(s)..."

            # Create multi-arch manifest
            docker buildx imagetools create \
              -t "${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:${MANIFEST_TAG}" \
              "${PLATFORM_IMAGES[@]}"

            echo "‚úÖ Created: $MANIFEST_TAG"
            echo "$MANIFEST_TAG" >> manifests-created.txt
            echo ""
          done

          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ All manifests created successfully"

      - name: Cleanup platform tags
        continue-on-error: true
        run: |
          echo "üßπ Cleaning up temporary platform tags..."
          echo ""

          SUCCESS_COUNT=0
          FAIL_COUNT=0

          for tag_file in platform-tags/platform-tag-*.txt; do
            if [ -f "$tag_file" ]; then
              PLATFORM_TAG=$(cat "$tag_file")
              FULL_IMAGE="${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:${PLATFORM_TAG}"

              echo "Deleting: $PLATFORM_TAG"

              if crane delete "$FULL_IMAGE" 2>/dev/null; then
                ((SUCCESS_COUNT++))
              else
                echo "  ‚ö†Ô∏è Failed to delete (may already be gone)"
                ((FAIL_COUNT++))
              fi
            fi
          done

          echo ""
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "‚úÖ Cleanup complete: $SUCCESS_COUNT deleted, $FAIL_COUNT failed"
          echo "Platform tags were temporary - manifests are permanent"

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.RUNLIX_APP_ID }}
          private-key: ${{ secrets.RUNLIX_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Get GitHub App Bot User ID
        id: get-user-id
        run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          path: main-branch
          token: ${{ steps.app-token.outputs.token }}

      - name: Update releases.json
        run: |
          cd main-branch

          VERSION="${{ needs.parse-matrix.outputs.version }}"
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          MANIFESTS=$(cat ../manifests-created.txt | jq -R -s 'split("\n") | map(select(length > 0))')

          # Read or create releases.json
          if [ -f releases.json ]; then
            RELEASES=$(cat releases.json)
          else
            RELEASES='{}'
          fi

          # Update entry for this service
          RELEASES=$(echo "$RELEASES" | jq \
            --arg service "$SERVICE_NAME" \
            --arg version "$VERSION" \
            --arg sha "${{ github.sha }}" \
            --arg short_sha "$SHORT_SHA" \
            --arg timestamp "$TIMESTAMP" \
            --argjson manifests "$MANIFESTS" \
            '.[$service] = {
              version: (if $version != "" then $version else null end),
              sha: $sha,
              short_sha: $short_sha,
              timestamp: $timestamp,
              manifests: $manifests
            }')

          # Write updated releases.json
          echo "$RELEASES" | jq '.' > releases.json

          echo "‚úÖ Updated releases.json for $SERVICE_NAME"
          echo ""
          echo "Release entry:"
          echo "$RELEASES" | jq --arg service "$SERVICE_NAME" '.[$service]'

      - name: Commit and push releases.json
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          cd main-branch

          # Configure git with GitHub App credentials
          git config user.name '${{ steps.app-token.outputs.app-slug }}[bot]'
          git config user.email '${{ steps.get-user-id.outputs.user-id }}+${{ steps.app-token.outputs.app-slug }}[bot]@users.noreply.github.com'

          # Setup git authentication for push
          gh auth setup-git

          git add releases.json

          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            VERSION="${{ needs.parse-matrix.outputs.version }}"
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)

            if [ -n "$VERSION" ]; then
              COMMIT_MSG="Release: $SERVICE_NAME $VERSION @ $SHORT_SHA"
            else
              COMMIT_MSG="Release: $SERVICE_NAME @ $SHORT_SHA"
            fi

            git commit -m "$COMMIT_MSG"
            git push

            echo "‚úÖ Pushed releases.json to main branch"
          fi

      - name: Upload manifest list
        uses: actions/upload-artifact@v4
        with:
          name: manifests-created
          path: manifests-created.txt
          retention-days: 90

      - name: Send release notification
        if: ${{ !inputs.pr_mode }}
        continue-on-error: true
        run: |
          VERSION="${{ needs.parse-matrix.outputs.version }}"
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          MANIFESTS=$(cat manifests-created.txt | tr '\n' ', ' | sed 's/,$//')

          echo "üì¢ Sending release notification..."
          echo "Service: $SERVICE_NAME"
          if [ -n "$VERSION" ]; then
            echo "Version: $VERSION"
          else
            echo "Version: $SHORT_SHA (SHA-based)"
          fi
          echo "Manifests: $MANIFESTS"

          # Prepare notification message (Telegram supports HTML and Markdown)
          if [ -n "$VERSION" ]; then
            VERSION_LINE="*Version:* \`$VERSION\`"
          else
            VERSION_LINE="*Version:* \`$SHORT_SHA\` (SHA-based)"
          fi

          MESSAGE=$(cat <<EOF
          üéâ *Docker Release Complete*

          *Service:* \`$SERVICE_NAME\`
          $VERSION_LINE
          *Commit:* [\`$SHORT_SHA\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})

          *Manifests Created:*
          \`$MANIFESTS\`

          *Registry:*
          \`${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}\`

          [View Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )

          # Send to Telegram bot if configured
          if [ -n "${{ secrets.TELEGRAM_BOT_TOKEN }}" ] && [ -n "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then
            echo "Sending to Telegram..."

            # URL encode the message for Telegram API
            ENCODED_MESSAGE=$(echo "$MESSAGE" | jq -sRr @uri)

            # Send via Telegram Bot API
            RESPONSE=$(curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
              -d "text=$MESSAGE" \
              -d "parse_mode=Markdown" \
              -d "disable_web_page_preview=true")

            # Check if successful
            if echo "$RESPONSE" | jq -e '.ok == true' > /dev/null; then
              echo "‚úÖ Notification sent to Telegram"
            else
              echo "‚ö†Ô∏è  Telegram API returned error:"
              echo "$RESPONSE" | jq -r '.description // "Unknown error"'
            fi
          else
            echo "‚ö†Ô∏è  TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID not configured, skipping notification"
            echo "To enable notifications:"
            echo "  1. Create a bot via @BotFather on Telegram"
            echo "  2. Get your chat ID by messaging @userinfobot"
            echo "  3. Add secrets: TELEGRAM_BOT_TOKEN and TELEGRAM_CHAT_ID"
          fi

          # Alternative: Create GitHub Release (commented out, enable if needed)
          # gh release create "$VERSION" \
          #   --title "Release $VERSION" \
          #   --notes "Automated release of $SERVICE_NAME $VERSION
          #
          # **Manifests Created:**
          # $(cat manifests-created.txt | sed 's/^/- /')
          #
          # **Commit:** ${{ github.sha }}
          # **Registry:** ${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}" \
          #   --repo ${{ github.repository }}

      - name: Release complete
        run: |
          echo "üéâ Release Complete"
          echo "==================="
          echo ""
          echo "Service: $SERVICE_NAME"

          VERSION="${{ needs.parse-matrix.outputs.version }}"
          if [ -n "$VERSION" ]; then
            echo "Version: $VERSION"
          else
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            echo "Version: $SHORT_SHA (SHA-based)"
          fi

          echo "Commit: ${{ github.sha }}"
          echo ""
          echo "Created manifests:"
          cat manifests-created.txt | sed 's/^/  - /'
          echo ""
          echo "Registry: ${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}"
          echo ""
          echo "Pull commands:"
          cat manifests-created.txt | while read tag; do
            echo "  docker pull ${REGISTRY}/${REGISTRY_ORG}/${SERVICE_NAME}:$tag"
          done

# Workflow outputs:
# - PR mode: Platform-specific images tagged pr-{number}-{version}-{suffix}-{arch}-{sha}
#            (version omitted for SHA-based services)
# - Release mode: Multi-arch manifests tagged {version}-{suffix} or {suffix} (SHA-based)
