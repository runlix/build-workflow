name: 'Check PR Images Exist'
description: |
  Checks if PR images exist in GitHub Container Registry (GHCR) by verifying the first target image.
  
  This action is used as an optimization: PR images are built for all targets together, so checking
  the first target is sufficient to determine if all PR images exist. The image tag format is:
  ghcr.io/{repository}:pr-{branch}-{version}-{target}-{sha}

inputs:
  repository:
    description: 'GitHub repository in owner/repo format (e.g., runlix/radarr)'
    required: true
  branch:
    description: 'Branch name (will be sanitized: slashes replaced with hyphens)'
    required: true
  version:
    description: 'Version string from VERSION.json'
    required: true
  pr_head_sha_short:
    description: 'PR head commit SHA shortened to 7 hex characters (e.g., 9e4b4f2)'
    required: true
  matrix:
    description: 'JSON array of build targets (from VERSION.json). Only the first target is checked as an optimization - if it exists, we assume all PR images exist.'
    required: true

outputs:
  pr_images_found:
    description: 'true if PR image exists for the first target, false otherwise'
    value: ${{ steps.check.outputs.pr_images_found }}

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        set -e
        set -o pipefail
        
        # Constants
        readonly ACTION_NAME="check-pr-images-exist"
        
        # ============================================================================
        # Extract Inputs to Variables
        # ============================================================================
        # Store inputs in variables first to avoid shell parsing issues with complex values
        REPOSITORY_INPUT="${{ inputs.repository }}"
        BRANCH_INPUT="${{ inputs.branch }}"
        VERSION_INPUT="${{ inputs.version }}"
        PR_HEAD_SHA_SHORT_INPUT="${{ inputs.pr_head_sha_short }}"
        
        # ============================================================================
        # Input Validation
        # ============================================================================
        
        # Validate required inputs (using variables to avoid shell parsing issues with complex values)
        # Check for empty or null values
        if [ -z "${REPOSITORY_INPUT}" ] || [ "${REPOSITORY_INPUT}" = "null" ]; then
          echo "::error::[VALIDATION_001] ${ACTION_NAME}: repository is required" >&2
          exit 1
        fi
        
        if [ -z "${BRANCH_INPUT}" ] || [ "${BRANCH_INPUT}" = "null" ]; then
          echo "::error::[VALIDATION_001] ${ACTION_NAME}: branch is required" >&2
          exit 1
        fi
        
        if [ -z "${VERSION_INPUT}" ] || [ "${VERSION_INPUT}" = "null" ]; then
          echo "::error::[VALIDATION_001] ${ACTION_NAME}: version is required" >&2
          exit 1
        fi
        
        if [ -z "${PR_HEAD_SHA_SHORT_INPUT}" ] || [ "${PR_HEAD_SHA_SHORT_INPUT}" = "null" ]; then
          echo "::error::[VALIDATION_001] ${ACTION_NAME}: pr_head_sha_short is required" >&2
          exit 1
        fi
        
        # Validate repository format (must be owner/repo)
        if ! [[ "${REPOSITORY_INPUT}" =~ ^[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+$ ]]; then
          echo "::error::[VALIDATION_002] ${ACTION_NAME}: Invalid repository format (expected: owner/repo, got: ${REPOSITORY_INPUT})" >&2
          exit 1
        fi
        
        # Validate SHA format (exactly 7 lowercase hex characters)
        if ! [[ "${PR_HEAD_SHA_SHORT_INPUT}" =~ ^[a-f0-9]{7}$ ]]; then
          echo "::error::[VALIDATION_003] ${ACTION_NAME}: Invalid pr_head_sha_short format (expected: 7 lowercase hex characters, got: ${PR_HEAD_SHA_SHORT_INPUT})" >&2
          exit 1
        fi
        
        # Validate matrix: use jq --arg to write JSON safely avoiding shell quote interpretation
        # jq --arg treats the value as a string literal and writes it correctly
        # This completely bypasses shell quote parsing
        MATRIX_TMP_FILE=$(mktemp)
        
        # #region agent log
        echo "DEBUG: About to write matrix using jq --arg to ${MATRIX_TMP_FILE}" >&2
        # #endregion
        
        # Use jq -n with --arg to write the JSON string to file
        # --arg treats the GitHub Actions expanded value as a string literal
        # This avoids shell interpretation because jq receives it as an argument, not shell variable
        if ! jq -n --arg matrix "${{ inputs.matrix }}" '$matrix' > "${MATRIX_TMP_FILE}" 2>&1; then
          echo "DEBUG: jq --arg write failed" >&2
          echo "::error::[VALIDATION_004] ${ACTION_NAME}: matrix must be valid JSON" >&2
          rm -f "${MATRIX_TMP_FILE}"
          exit 1
        fi
        
        # #region agent log
        echo "DEBUG: File written via jq, size: $(wc -c < "${MATRIX_TMP_FILE}") bytes" >&2
        echo "DEBUG: First 200 chars of file: $(head -c 200 "${MATRIX_TMP_FILE}")" >&2
        echo "DEBUG: jq validation attempt..." >&2
        # #endregion
        
        # Validate matrix is valid JSON and a non-empty array from the file
        # Read from file (which now contains the JSON string) and parse with fromjson
        JQ_OUTPUT=$(jq -e 'fromjson | type == "array" and length > 0' < "${MATRIX_TMP_FILE}" 2>&1)
        JQ_EXIT=$?
        
        # #region agent log
        echo "DEBUG: jq validation exit code: ${JQ_EXIT}" >&2
        echo "DEBUG: jq validation output: ${JQ_OUTPUT}" >&2
        # #endregion
        
        if [ ${JQ_EXIT} -ne 0 ]; then
          JQ_PARSE_OUTPUT=$(jq -e 'fromjson' < "${MATRIX_TMP_FILE}" 2>&1)
          JQ_PARSE_EXIT=$?
          
          # #region agent log
          echo "DEBUG: jq parse test exit code: ${JQ_PARSE_EXIT}" >&2
          echo "DEBUG: jq parse output: ${JQ_PARSE_OUTPUT}" >&2
          # #endregion
          
          if [ ${JQ_PARSE_EXIT} -ne 0 ]; then
            echo "::error::[VALIDATION_004] ${ACTION_NAME}: matrix must be valid JSON" >&2
          else
            echo "::error::[VALIDATION_005] ${ACTION_NAME}: matrix must be a non-empty JSON array" >&2
          fi
          rm -f "${MATRIX_TMP_FILE}"
          exit 1
        fi
        rm -f "${MATRIX_TMP_FILE}"
    
    - name: Check if PR images exist
      id: check
      shell: bash
      run: |
        set -e
        
        # ============================================================================
        # Extract and Prepare Inputs
        # ============================================================================
        
        REPOSITORY="${{ inputs.repository }}"
        BRANCH="${{ inputs.branch }}"
        VERSION="${{ inputs.version }}"
        PR_HEAD_SHA_SHORT="${{ inputs.pr_head_sha_short }}"
        
        # Sanitize branch name: replace slashes with hyphens for Docker tag compatibility
        # Example: "feature/new-ui" -> "feature-new-ui"
        BRANCH_SANITIZED="${BRANCH//\//-}"
        
        # ============================================================================
        # Extract First Target from Matrix
        # ============================================================================
        
        # Extract the first target name from the matrix
        # Optimization: We only check the first target because:
        # - PR images are built for all targets together in a single workflow run
        # - If the first target exists, all targets should exist
        # Write JSON to temp file using jq --arg, then read from file to avoid shell quoting issues
        MATRIX_TMP_FILE=$(mktemp)
        jq -n --arg matrix "${{ inputs.matrix }}" '$matrix' > "${MATRIX_TMP_FILE}" 2>/dev/null
        FIRST_TARGET_NAME=$(jq -r 'fromjson | .[0].name // empty' < "${MATRIX_TMP_FILE}" 2>/dev/null || echo "")
        rm -f "${MATRIX_TMP_FILE}"
        
        if [ -z "${FIRST_TARGET_NAME}" ]; then
          echo "âš ï¸  No target name found in first matrix entry"
          PR_IMAGES_FOUND="false"
        else
          # ============================================================================
          # Construct Image Tag and Check Existence
          # ============================================================================
          
          # Construct PR image tag following the format:
          # ghcr.io/{repository}:pr-{branch}-{version}-{target}-{sha}
          # Example: ghcr.io/runlix/radarr:pr-release-4.0.16.2944-amd64-latest-9e4b4f2
          PR_IMAGE_TAG="ghcr.io/${REPOSITORY}:pr-${BRANCH_SANITIZED}-${VERSION}-${FIRST_TARGET_NAME}-${PR_HEAD_SHA_SHORT}"
          
          echo "ðŸ” Checking for PR image: ${PR_IMAGE_TAG}"
          
          # Use docker buildx imagetools to check if image exists in GHCR
          # Suppress output (redirect to /dev/null) and check exit code
          if docker buildx imagetools inspect "${PR_IMAGE_TAG}" >/dev/null 2>&1; then
            echo "âœ… Found PR image: ${PR_IMAGE_TAG}"
            PR_IMAGES_FOUND="true"
          else
            echo "âŒ PR image not found: ${PR_IMAGE_TAG}"
            PR_IMAGES_FOUND="false"
          fi
        fi
        
        # ============================================================================
        # Set Output
        # ============================================================================
        
        echo "pr_images_found=${PR_IMAGES_FOUND}" >> $GITHUB_OUTPUT
        echo ""
        echo "ðŸ“Š Result: PR images found = ${PR_IMAGES_FOUND}"
