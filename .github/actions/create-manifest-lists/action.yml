name: 'Create Manifest Lists'
description: 'Create and push Docker manifest lists for multi-platform images'

inputs:
  variants:
    description: 'Multiline string of variants'
    required: true
  version:
    description: 'Version string'
    required: true
  branch:
    description: 'Branch name'
    required: true
  sha:
    description: 'Git commit SHA'
    required: true
  repository:
    description: 'GitHub repository (e.g., owner/repo)'
    required: true
  matrix:
    description: 'JSON array of enabled targets'
    required: true

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        set -e
        set -o pipefail
        
        ACTION_NAME="create-manifest-lists"
        
        # Store inputs in variables for safe handling
        VARIANTS_INPUT="${{ inputs.variants }}"
        VERSION_INPUT="${{ inputs.version }}"
        BRANCH_INPUT="${{ inputs.branch }}"
        SHA_INPUT="${{ inputs.sha }}"
        REPOSITORY_INPUT="${{ inputs.repository }}"
        MATRIX_INPUT="${{ inputs.matrix }}"
        
        # Validate all required inputs
        if [ -z "${VARIANTS_INPUT}" ] || [ "${VARIANTS_INPUT}" = "null" ]; then
          echo "::error::[VALIDATION_001] ${ACTION_NAME}: variants is required" >&2
          exit 1
        fi
        
        if [ -z "${VERSION_INPUT}" ] || [ "${VERSION_INPUT}" = "null" ]; then
          echo "::error::[VALIDATION_001] ${ACTION_NAME}: version is required" >&2
          exit 1
        fi
        
        if [ -z "${BRANCH_INPUT}" ] || [ "${BRANCH_INPUT}" = "null" ]; then
          echo "::error::[VALIDATION_001] ${ACTION_NAME}: branch is required" >&2
          exit 1
        fi
        
        if [ -z "${SHA_INPUT}" ] || [ "${SHA_INPUT}" = "null" ]; then
          echo "::error::[VALIDATION_001] ${ACTION_NAME}: sha is required" >&2
          exit 1
        fi
        
        # Validate SHA format (40 hex characters)
        if ! [[ "${SHA_INPUT}" =~ ^[a-f0-9]{40}$ ]]; then
          echo "::error::[VALIDATION_003] ${ACTION_NAME}: Invalid SHA format (expected: 40 hex characters)" >&2
          exit 1
        fi
        
        if [ -z "${REPOSITORY_INPUT}" ] || [ "${REPOSITORY_INPUT}" = "null" ]; then
          echo "::error::[VALIDATION_001] ${ACTION_NAME}: repository is required" >&2
          exit 1
        fi
        
        # Validate repository format (owner/repo)
        if ! [[ "${REPOSITORY_INPUT}" =~ ^[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+$ ]]; then
          echo "::error::[VALIDATION_004] ${ACTION_NAME}: Invalid repository format (expected: owner/repo)" >&2
          exit 1
        fi
        
        # Validate matrix: use jq exclusively for JSON validation
        # Check for empty input first (simple shell check is safe here)
        if [ -z "${MATRIX_INPUT}" ]; then
          echo "::error::[VALIDATION_001] ${ACTION_NAME}: matrix is required" >&2
          exit 1
        fi
        
        # Validate matrix is valid JSON and a non-empty array using jq
        # This handles all JSON-related validation without shell quoting issues
        # Use printf instead of echo for safer string handling
        if ! printf '%s\n' "${MATRIX_INPUT}" | jq -e 'type == "array" and length > 0' >/dev/null 2>&1; then
          # Check if it's invalid JSON or just empty/null
          if ! printf '%s\n' "${MATRIX_INPUT}" | jq empty >/dev/null 2>&1; then
            echo "::error::[VALIDATION_004] ${ACTION_NAME}: matrix must be valid JSON" >&2
          else
            echo "::error::[VALIDATION_005] ${ACTION_NAME}: matrix must be a non-empty JSON array" >&2
          fi
          exit 1
        fi
    
    - name: Create and push manifest lists
      shell: bash
      run: |
        VARIANTS="${{ inputs.variants }}"
        VERSION="${{ inputs.version }}"
        BRANCH="${{ inputs.branch }}"
        SHA="${{ inputs.sha }}"
        REPOSITORY="${{ inputs.repository }}"
        MATRIX="${{ inputs.matrix }}"
        
        # Ensure matrix is treated as JSON string (already validated above)
        
        # Sanitize branch name: replace '/' with '-' for valid Docker tag
        BRANCH_SANITIZED="${BRANCH//\//-}"
        
        # Retry function for manifest operations
        retry_manifest_operation() {
          local max_attempts=3
          local attempt=1
          local wait_seconds=30
          
          while [ $attempt -le $max_attempts ]; do
            if [ $attempt -gt 1 ]; then
              echo "Retry attempt $attempt of $max_attempts (waiting ${wait_seconds}s)..."
              sleep $wait_seconds
            fi
            
            if "$@"; then
              return 0
            fi
            
            attempt=$((attempt + 1))
          done
          
          echo "Failed after $max_attempts attempts"
          return 1
        }
        
        # For each variant, collect platform images and create manifest list
        echo "$VARIANTS" | while IFS= read -r variant; do
          echo "Processing variant: $variant"
          
          # Get all enabled targets for this variant from matrix JSON
          # Use printf instead of echo for safer string handling
          TARGETS=$(printf '%s\n' "$MATRIX" | jq -r --arg v "$variant" '.[] | select(.variant == $v) | .name')
          
          # Build image tag list and verify existence
          PLATFORM_IMAGES=()
          for target in $TARGETS; do
            IMAGE_TAG="ghcr.io/${REPOSITORY}:${BRANCH_SANITIZED}-${VERSION}-${target}"
            if docker buildx imagetools inspect "$IMAGE_TAG" >/dev/null 2>&1; then
              PLATFORM_IMAGES+=("$IMAGE_TAG")
              echo "  ✓ Found: $IMAGE_TAG"
            else
              echo "  ✗ Missing: $IMAGE_TAG"
            fi
          done
          
          # Only create manifest if we have at least 2 platforms
          if [ ${#PLATFORM_IMAGES[@]} -lt 2 ]; then
            echo "Skipping manifest creation for $variant: only ${#PLATFORM_IMAGES[@]} platform(s) available"
            continue
          fi
          
          # Define primary tag (first tag becomes the manifest reference)
          PRIMARY_TAG="ghcr.io/${REPOSITORY}:${BRANCH_SANITIZED}-${variant}"
          
          # Create manifest list once with primary tag (with retry)
          echo "Creating manifest list: $PRIMARY_TAG"
          retry_manifest_operation docker buildx imagetools create \
            --tag "$PRIMARY_TAG" \
            "${PLATFORM_IMAGES[@]}"
          
          # Create additional tags as aliases pointing to the same manifest
          # This is more efficient than creating separate manifests (matches Hotio pattern)
          echo "Creating tag alias: ${BRANCH_SANITIZED}-${VERSION}-${variant}"
          retry_manifest_operation docker buildx imagetools create \
            --tag "ghcr.io/${REPOSITORY}:${BRANCH_SANITIZED}-${VERSION}-${variant}" \
            "$PRIMARY_TAG"
          
          echo "Creating tag alias: ${BRANCH_SANITIZED}-${SHA:0:7}-${variant}"
          retry_manifest_operation docker buildx imagetools create \
            --tag "ghcr.io/${REPOSITORY}:${BRANCH_SANITIZED}-${SHA:0:7}-${variant}" \
            "$PRIMARY_TAG"
          
          echo "✓ Manifest list created for variant: $variant with all tag aliases"
        done

